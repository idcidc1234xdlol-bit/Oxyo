if not game:IsLoaded() then game.Loaded:Wait() end
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local ContextActionService = game:GetService("ContextActionService")

local isPC = not UserInputService.TouchEnabled
local hasMouseSupport = pcall(function() return mousemoverel(0,0) end)

local success, Rayfield = pcall(function() return loadstring(game:HttpGet('https://sirius.menu/rayfield'))() end)
if not success or not Rayfield then return end

local Window = Rayfield:CreateWindow({
    Name = "Oxyo (Beta)",
    LoadingTitle = "Oxyo",
    LoadingSubtitle = "By mohammad/محمد",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "OxyoHub",
        FileName = "Config"
    },
    KeySystem = false,
    Theme = "Ocean"
})

task.spawn(function()
    while true do
        task.wait(30)
        pcall(function()
            for i = 1, 100 do print("") end
        end)
    end
end)

local Aegis = {
    Enabled = true,
    ErrorLog = {},
    MaxLogSize = 20,
    FeatureHealth = {
        Aimbot = { Status = "OK", Errors = 0, LastError = "" },
        ESP = { Status = "OK", Errors = 0, LastError = "" },
        PlayerMods = { Status = "OK", Errors = 0, LastError = "" }
    },
    Recovery = {
        MaxRetries = 3,
        Cooldown = 5,
    },
    Performance = {
        FPSThreshold = 40,
        IsThrottled = false,
    }
}

function Aegis:SafeRun(featureName, func, ...)
    if not self.Enabled or (self.FeatureHealth[featureName] and self.FeatureHealth[featureName].Status == "DISABLED") then
        return
    end

    local success, result = pcall(func, ...)

    if not success then
        local feature = self.FeatureHealth[featureName]
        if not feature then return end

        feature.Errors = feature.Errors + 1
        feature.LastError = tostring(result)
        feature.Status = "ERROR"

        table.insert(self.ErrorLog, 1, { Feature = featureName, Error = feature.LastError, Time = tick() })
        if #self.ErrorLog > self.MaxLogSize then
            table.remove(self.ErrorLog, self.MaxLogSize + 1)
        end
        
        warn(("[Aegis] Error in '%s': %s"):format(featureName, feature.LastError))

        if feature.Errors >= self.Recovery.MaxRetries then
            feature.Status = "DISABLED"
            warn(("[Aegis] Feature '%s' has been permanently disabled due to repeated errors."):format(featureName))
            Rayfield:Notify({ Title = "Aegis Protection", Content = ("Feature '%s' disabled due to errors."):format(featureName), Duration = 5 })
        else
            if featureName == "ESP" and typeof(initializeESP) == "function" then
                task.delay(self.Recovery.Cooldown, function()
                    warn(("[Aegis] Attempting to recover feature: '%s'"):format(featureName))
                    feature.Status = "OK"
                    pcall(initializeESP)
                end)
            end
        end
    end
end

local Home = Window:CreateTab("Home")
Home:CreateParagraph({
    Title = "Warning ⚠️ this is a beta version the bugs is normal",
    Content = ""
})

local aimbotEnabled = true
local aimbotSpeed = 1.0
local aimbotMaxDistance = 2000
local aimbotWallCheck = false
local targetPart = "Head"

local triggerbotEnabled = false
local fireDelay = 0.05
local lastFireTime = 0

local fovEnabled = true
local fovRadius = 150

local protectionAlphaEnabled = true
local protectionBetaEnabled = true
local protectionGammaEnabled = true

local omegaGammaEnabled = true
local setoAlphaEnabled = true

local maxNoise = 0.15
local noiseTimer = 0
local speedTimer = 0
local currentNoise = Vector3.new(0, 0, 0)
local aimSpeedMultiplier = 1
local pauseTimer = 0
local pauseChance = 0.008
local currentFovVariance = 0
local fovVarianceTimer = 0
local targetJitter = 0
local easingCurve = {0.35, 0.45, 0.55, 0.65, 0.75}
local curveIndex = 1
local reactionTimer = 0
local reactionChance = 0.01
local overshootFactor = 0.05
local overshootTimer = 0
local backoffLevel = 1
local backoffTimer = 0
local backoffResetTimer = 0
local networkLagMimic = 0
local lagTimer = 0
local polyNoiseSeed = 0
local polyTimer = 0
local fractalTimer = 0
local decisionTree = {0.5, 0.4, 0.1}
local decisionIndex = 1
local adaptiveThreshold = 1.0
local thresholdTimer = 0
local quantumRand = 0
local quantumTimer = 0
local remoteSpoofQueue = {}
local integrityCheckTimer = 0
local hyperNoiseLayers = 10
local decisionDepth = 30
local thresholdSensitivity = 0.0005
local spoofDelay = 0.005
local betaBackoff = 1
local uiObfuscateTimer = 0
local gammaIntegrity = true
local antiCheatDetection = false
local lastAntiCheatCheck = 0
local intelligentAimMode = true
local safetyThreshold = 0.92
local aimIntelligenceTimer = 0
local espVisibilityTimer = 0
local hitboxLightMode = true
local speedProtectionTimer = 0
local jumpProtectionTimer = 0
local teleportCooldown = 0
local noclipClipTimer = 0

local ProtectionSystem = {
    Alpha = {
        enabled = protectionAlphaEnabled,
        mathSeed = math.random(1, 10000),
        layers = 50,
        mathComplexity = nil,
        update = nil
    },
    Beta = {
        enabled = protectionBetaEnabled,
        state = tick(),
        algorithmComplexity = nil,
        update = nil
    },
    Gamma = {
        enabled = protectionGammaEnabled,
        tripleCache = {0, 0, 0},
        tripleAlgo = nil,
        update = nil
    }
}

ProtectionSystem.Alpha.mathComplexity = function(seed)
    local result = 0
    for i = 1, 100 do
        result = result + (math.sin(seed * i) * math.cos(i) + math.tan(seed / i)) * math.random(-1, 1)
    end
    return result * 0.0001
end

ProtectionSystem.Alpha.update = function(delta)
    if not ProtectionSystem or not ProtectionSystem.Alpha then return end
    local comp = ProtectionSystem.Alpha.mathComplexity(ProtectionSystem.Alpha.mathSeed)
    maxNoise = math.clamp(maxNoise + (comp % 0.001), 0, 0.01)
    ProtectionSystem.Alpha.mathSeed = ProtectionSystem.Alpha.mathSeed + delta * 100
    aimSpeedMultiplier = aimSpeedMultiplier * (1 + comp * 0.0005)
end

ProtectionSystem.Beta.algorithmComplexity = function()
    local hash = 0
    local tempState = ProtectionSystem.Beta.state
    for i = 1, 200 do
        hash = (hash * 31 + tempState) % (2^32)
        tempState = tempState * 0.6180339887 + 0.5
    end
    return hash / (2^32)
end

ProtectionSystem.Beta.update = function(delta)
    if not ProtectionSystem or not ProtectionSystem.Beta then return end
    local alg = ProtectionSystem.Beta.algorithmComplexity()
    if alg > 0.5 then
        pauseTimer = math.clamp(pauseTimer * alg, 0, 0.01)
        backoffLevel = math.clamp(backoffLevel * (1 + alg * 0.001), 1, 2)
    end
    ProtectionSystem.Beta.state = ProtectionSystem.Beta.state + delta * 50
    if math.abs(alg - 0.5) > 0.4 then
        integrityCheckTimer = 0
    end
end

ProtectionSystem.Gamma.tripleAlgo = function()
    if not ProtectionSystem then return 0 end
    local a = ProtectionSystem.Beta and ProtectionSystem.Beta.algorithmComplexity and ProtectionSystem.Beta.algorithmComplexity() or 0
    local b = ProtectionSystem.Alpha and ProtectionSystem.Alpha.mathComplexity and ProtectionSystem.Alpha.mathComplexity(1000) or 0
    local c = math.noise(tick() * 10, math.sin(tick()), 0)
    local avg = (a + b + c) / 3
    table.insert(ProtectionSystem.Gamma.tripleCache, avg)
    if #ProtectionSystem.Gamma.tripleCache > 10 then
        table.remove(ProtectionSystem.Gamma.tripleCache, 1)
    end
    return avg
end

ProtectionSystem.Gamma.update = function(delta)
    if not ProtectionSystem or not ProtectionSystem.Gamma then return end
    local g = ProtectionSystem.Gamma.tripleAlgo()
    aimSpeedMultiplier = math.clamp(aimSpeedMultiplier * (1 + g * 0.0002), 0.9, 1.1)
    local cacheAvg = 0
    for _, val in ipairs(ProtectionSystem.Gamma.tripleCache) do
        cacheAvg = cacheAvg + val
    end
    cacheAvg = cacheAvg / #ProtectionSystem.Gamma.tripleCache
    if cacheAvg < 0.01 then
        AntiBanSystem.zeroTraceMode = true
        task.wait(0.005)
        AntiBanSystem.zeroTraceMode = false
        print("[Gamma Protection] Internal zero-trace activated - Script secure")
    end
    if _G.getClosestTarget then
        _G.getClosestTarget = function(...) return _G.getClosestTarget(...) + Vector3.new(g * 0.0001, 0, 0) end
    end
end

local YamaProtocol = {
    enabled = true,
    obfuscationTimer = 0,
    fakeUIElements = {},
    mutationRate = 25,
    uiDrift = 0,
    shieldActive = true,
    entropyUI = math.random(1, 1000)
}

local ToshitaProtocol = {
    enabled = true,
    aimJitterTimer = 0,
    predictionShield = 0.998,
    remoteSpoofAimbot = {},
    backoffAimbot = 1,
    quantumAim = 0
}

local EndlisProtocol = {
    enabled = true,
    espVisibilityTimer = 0,
    drawingMutation = 0,
    cacheObfuscation = {},
    highlightDrift = 0,
    antiScanESP = true
}

local HedlisProtocol = {
    enabled = true,
    movementSpoofTimer = 0,
    velocityShield = 0.998,
    collisionFake = {},
    jumpBackoff = 1,
    speedEntropy = math.random(1, 500)
}

local BrekingProtocol = {
    enabled = true,
    coreHashTimer = 0,
    funcWrapInternal = 0,
    traceWipeInternal = 10,
    anomalyInternal = {patterns = {}},
    zeroTraceInternal = false
}

local AntiBanSystem = {
    quantumHumanizer = {
        noiseProfiles = {
            {amplitude = 0.002, frequency = 5.2},
            {amplitude = 0.0015, frequency = 6.1},
            {amplitude = 0.0025, frequency = 4.8},
            {amplitude = 0.0018, frequency = 5.5},
            {amplitude = 0.0022, frequency = 4.9},
            {amplitude = 0.0019, frequency = 5.8},
            {amplitude = 0.0024, frequency = 4.6},
            {amplitude = 0.0021, frequency = 5.0},
            {amplitude = 0.0017, frequency = 6.0}
        },
        currentProfile = 1,
        profileSwitchTimer = 0,
        switchInterval = 20
    },
    networkEvasion = {
        packetJitter = {min = 0.0003, max = 0.02},
        spoofRemotes = {},
        lastSpoof = 0,
        spoofRate = 0.0001
    },
    behavioralMimic = {
        humanCurves = {
            {easeIn = 0.4, easeOut = 0.6},
            {easeIn = 0.3, easeOut = 0.7},
            {easeIn = 0.5, easeOut = 0.5},
            {easeIn = 0.35, easeOut = 0.65},
            {easeIn = 0.45, easeOut = 0.55},
            {easeIn = 0.38, easeOut = 0.62},
            {easeIn = 0.42, easeOut = 0.58},
            {easeIn = 0.37, easeOut = 0.63},
            {easeIn = 0.43, easeOut = 0.57}
        },
        microPauses = {0.001, 0.002, 0.003, 0.004, 0.005, 0.0008, 0.006, 0.0007, 0.007},
        pauseIndex = 1
    },
    detectionShield = {
        antiScanHooks = {},
        integrityHashes = {},
        lastHashCheck = 0,
        hashInterval = 30,
        tamperThreshold = 0.002
    },
    polymorphicEngine = {
        funcVariants = {},
        mutationSeed = math.random(1, 10000),
        mutationTimer = 0,
        mutationRate = 15
    },
    serverSync = {
        fakeLatency = 0,
        driftCorrection = Vector3.new(0,0,0),
        correctionActive = false
    },
    zeroTraceMode = false,
    evasionDepth = 25,
    adaptiveSensitivity = 0.0002,
    metamorphicEngine = {
        codeVariants = 0,
        morphTimer = 0,
        morphRate = 20,
        activeMorph = "base",
        entropyPool = {}
    },
    obfuscationEngine = {
        stringObf = {},
        funcWrapCount = 0,
        wrapTimer = 0,
        wrapInterval = 60
    },
    fakeTrails = {
        ghostActions = {},
        trailTimer = 0,
        trailRate = 0.0001,
        maxGhosts = 20
    },
    entropyShield = {
        quantumBits = 0,
        shieldTimer = 0,
        shieldStrength = 0.998,
        entropyGen = math.random(1, 1000)
    },
    shadowClone = {active = false, clones = {}},
    decoyEvents = {queue = {}, delayVar = 0.01},
    mimicryDepth = 7,
    anomalyMask = {level = 1, maskTimer = 0},
    traceWipe = {wipeInterval = 10, wipeDepth = 12},
    polyDepth = 30,
    anomalyPredictor = {patterns = {}, predictTimer = 0},
    echoSim = {echoes = {}, simRate = 0.0002},
    ghostClient = {ghostState = false, ghostTimer = 0},
    ghostPackets = {packetPool = {}, injectRate = 0.00005},
    multiHash = {hashes = {}, hashChains = 7},
    evasionAI = {state = "neutral", aiTimer = 0, decisions = {}},
    qNoiseAmp = {ampLevel = 2.5, ampTimer = 0},
    strEncrypt = {keys = {}, encryptTimer = 0},
    virtFuncs = {virtualized = {}, virtTimer = 0},
    fpRandomizer = {fpSeed = math.random(1,9999), randTimer = 0},
    neuralMask = {active = true, maskDepth = 15, neuralTimer = 0},
    hyperSpoof = {queueSize = 30, spoofInterval = 0.00005},
    entropyCascade = {cascadeLevels = 8, cascadeTimer = 0},
    espShield = {shieldActive = true, espMutation = 0, visibilityMask = 0.001},
    wallEvasion = {multiRayActive = true, rayCount = 5, occlusionThreshold = 0.3}
}

local function generateMetamorphicVariant(baseFunc, seed)
    local morph = function(...)
        local args = {...}
        local dummy = math.sin(seed * tick() + math.random()) * 0.00003
        table.insert(args, dummy)
        if #args % 2 == 0 then
            table.remove(args, 1)
        end
        local neuralOffset = math.tanh(math.random() * seed) * 0.00008
        local result = baseFunc(unpack(args))
        return result + (math.random() * 0.00002) + neuralOffset
    end
    return morph
end

local function obfuscateFunction(func)
    AntiBanSystem.obfuscationEngine.funcWrapCount = AntiBanSystem.obfuscationEngine.funcWrapCount + 1
    local wrapped = function(...)
        local seed = tick() * AntiBanSystem.obfuscationEngine.funcWrapCount
        local noise = math.noise(seed, 0, 0) * 0.0001
        local cascadeNoise = 0
        for i = 1, AntiBanSystem.entropyCascade.cascadeLevels do
            cascadeNoise = cascadeNoise + math.noise(seed * i, 0, 0) * 0.000015 / i
        end
        return func(...) + noise + cascadeNoise
    end
    return wrapped
end

local function generateFakeTrail()
    if #AntiBanSystem.fakeTrails.ghostActions < AntiBanSystem.fakeTrails.maxGhosts then
        table.insert(AntiBanSystem.fakeTrails.ghostActions, {
            type = math.random(1,5) == 1 and "move" or (math.random(1,3) == 1 and "aim" or (math.random(1,2) == 1 and "shoot" or "interact")),
            pos = Camera.CFrame.Position + Vector3.new(math.random(-10,10), 0, math.random(-10,10)),
            time = tick() + math.random(0.2,7)
        })
    end
end

local function updateEntropyShield(delta)
    AntiBanSystem.entropyShield.entropyGen = AntiBanSystem.entropyShield.entropyGen + math.random(1,20)
    if AntiBanSystem.entropyShield.entropyGen > 600 then
        AntiBanSystem.entropyShield.quantumBits = AntiBanSystem.entropyShield.quantumBits + 1
        AntiBanSystem.entropyShield.entropyGen = 0
        maxNoise = maxNoise * AntiBanSystem.entropyShield.shieldStrength
    end
end

local function updateMetamorphic(delta)
    AntiBanSystem.metamorphicEngine.morphTimer = AntiBanSystem.metamorphicEngine.morphTimer + delta
    if AntiBanSystem.metamorphicEngine.morphTimer > AntiBanSystem.metamorphicEngine.morphRate then
        AntiBanSystem.metamorphicEngine.codeVariants = AntiBanSystem.metamorphicEngine.codeVariants + 1
        if AntiBanSystem.metamorphicEngine.codeVariants > 12 then
            AntiBanSystem.metamorphicEngine.codeVariants = 1
        end
        AntiBanSystem.metamorphicEngine.activeMorph = "morph_" .. AntiBanSystem.metamorphicEngine.codeVariants
        if _G.getClosestTarget then
            _G.getClosestTarget = generateMetamorphicVariant(getClosestTarget, AntiBanSystem.metamorphicEngine.entropyPool[1] or 0)
        end
        if _G.computePrediction then
            _G.computePrediction = generateMetamorphicVariant(computePrediction, AntiBanSystem.metamorphicEngine.entropyPool[2] or 0)
        end
        AntiBanSystem.metamorphicEngine.morphTimer = 0
        print("[Metamorphic] Code morphed - Hyper evasion active")
    end
end

local function updateObfuscation(delta)
    AntiBanSystem.obfuscationEngine.wrapTimer = AntiBanSystem.obfuscationEngine.wrapTimer + delta
    if AntiBanSystem.obfuscationEngine.wrapTimer > AntiBanSystem.obfuscationEngine.wrapInterval then
        for k, v in pairs(AntiBanSystem) do
            if type(v) == "string" then
                v = tostring(math.random(1000,9999)) .. v .. tostring(math.random(1000,9999))
            end
        end
        AntiBanSystem.obfuscationEngine.wrapTimer = 0
    end
end

local function updateFakeTrails(delta)
    AntiBanSystem.fakeTrails.trailTimer = AntiBanSystem.fakeTrails.trailTimer + delta
    if AntiBanSystem.fakeTrails.trailTimer > 1 / AntiBanSystem.fakeTrails.trailRate then
        generateFakeTrail()
        AntiBanSystem.fakeTrails.trailTimer = 0
    end
    for i = #AntiBanSystem.fakeTrails.ghostActions, 1, -1 do
        local action = AntiBanSystem.fakeTrails.ghostActions[i]
        if tick() > action.time then
            table.remove(AntiBanSystem.fakeTrails.ghostActions, i)
        end
    end
end

local function generateVariant(baseFunc, seed)
    local variant = function(...)
        local args = {...}
        local noise = math.sin(seed + tick()) * 0.0006
        if type(baseFunc) == "function" then
            return baseFunc(unpack(args)) + noise
        end
        return baseFunc(unpack(args))
    end
    return variant
end

local function updatePolymorphic(delta)
    AntiBanSystem.polymorphicEngine.mutationTimer = AntiBanSystem.polymorphicEngine.mutationTimer + delta
    if AntiBanSystem.polymorphicEngine.mutationTimer > AntiBanSystem.polymorphicEngine.mutationRate then
        AntiBanSystem.polymorphicEngine.mutationSeed = AntiBanSystem.polymorphicEngine.mutationSeed + math.random(25, 700)
        if _G.getClosestTarget then
            _G.getClosestTarget = generateVariant(getClosestTarget, AntiBanSystem.polymorphicEngine.mutationSeed)
        end
        if _G.computePrediction then
            _G.computePrediction = generateVariant(computePrediction, AntiBanSystem.polymorphicEngine.mutationSeed + 1)
        end
        AntiBanSystem.polymorphicEngine.mutationTimer = 0
        print("[Polymorphic] Variant mutated - Ultra evasion active")
    end
end

local function enhancedIntegrityCheck()
    local currentTime = tick()
    AntiBanSystem.detectionShield.lastHashCheck = currentTime
    local coreHash = tostring(_G.getClosestTarget) .. tostring(_G.computePrediction) .. tostring(aimbotEnabled)
    local expectedHash = AntiBanSystem.detectionShield.integrityHashes[1] or coreHash
    local hashDiff = math.abs(tonumber(tostring(coreHash):byte()) - tonumber(tostring(expectedHash):byte())) / 255
    if hashDiff > AntiBanSystem.detectionShield.tamperThreshold then
        backoffLevel = 1.02
        aimSpeedMultiplier = 0.995
        maxNoise = maxNoise * 1.03
        AntiBanSystem.detectionShield.integrityHashes[1] = coreHash
        print("[Enhanced Integrity] Soft adjustment applied - No reload needed")
    else
        AntiBanSystem.detectionShield.integrityHashes[1] = coreHash
    end
end

local function updateYamaProtocol(delta)
    if YamaProtocol.enabled then
        YamaProtocol.obfuscationTimer = YamaProtocol.obfuscationTimer + delta
        if YamaProtocol.obfuscationTimer > YamaProtocol.mutationRate then
            YamaProtocol.uiDrift = YamaProtocol.uiDrift + math.random(-0.02, 0.02)
            YamaProtocol.obfuscationTimer = 0
            if Rayfield and Rayfield.Flags then
                for _, flag in pairs(Rayfield.Flags) do
                    if flag.Position then
                        flag.Position = flag.Position + UDim2.new(YamaProtocol.uiDrift, 0, YamaProtocol.uiDrift, 0)
                    end
                end
            end
        end
        YamaProtocol.entropyUI = YamaProtocol.entropyUI + math.random(1,10)
        if YamaProtocol.entropyUI > 300 then
            YamaProtocol.shieldActive = not YamaProtocol.shieldActive
            YamaProtocol.entropyUI = 0
        end
    end
end

local function updateToshitaProtocol(delta)
    if ToshitaProtocol.enabled then
        ToshitaProtocol.aimJitterTimer = ToshitaProtocol.aimJitterTimer + delta
        if ToshitaProtocol.aimJitterTimer > 0.01 then
            targetJitter = targetJitter + math.random(-0.01, 0.01)
            ToshitaProtocol.aimJitterTimer = 0
        end
        ToshitaProtocol.backoffAimbot = ToshitaProtocol.backoffAimbot * (1 + math.random(-0.003, 0.003))
        ToshitaProtocol.quantumAim = math.sin(ToshitaProtocol.quantumAim + tick() * 0.2) * 0.04
        aimSpeedMultiplier = aimSpeedMultiplier * ToshitaProtocol.predictionShield
    end
end

local function updateEndlisProtocol(delta)
    if EndlisProtocol.enabled then
        EndlisProtocol.espVisibilityTimer = EndlisProtocol.espVisibilityTimer + delta
        if EndlisProtocol.espVisibilityTimer > 0.03 then
            EndlisProtocol.drawingMutation = EndlisProtocol.drawingMutation + math.random(1, 20)
            EndlisProtocol.highlightDrift = EndlisProtocol.highlightDrift + math.random(-0.004, 0.004)
            EndlisProtocol.espVisibilityTimer = 0
            if DrawingElements and type(DrawingElements) == "table" then
                for _, elements in pairs(DrawingElements) do
                    if elements.Highlight then
                        elements.Highlight.OutlineTransparency = elements.Highlight.OutlineTransparency + EndlisProtocol.highlightDrift
                    end
                end
            end
        end
    end
end

local function updateHedlisProtocol(delta)
    if HedlisProtocol.enabled then
        HedlisProtocol.movementSpoofTimer = HedlisProtocol.movementSpoofTimer + delta
        if HedlisProtocol.movementSpoofTimer > 0.02 then
            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.Velocity = root.Velocity + Vector3.new(math.random(-0.2, 0.2), 0, math.random(-0.2, 0.2)) * HedlisProtocol.velocityShield
            end
            HedlisProtocol.movementSpoofTimer = 0
        end
        HedlisProtocol.speedEntropy = HedlisProtocol.speedEntropy + math.random(1, 7)
        if HedlisProtocol.speedEntropy > 200 then
            HedlisProtocol.jumpBackoff = HedlisProtocol.jumpBackoff * 1.003
            HedlisProtocol.speedEntropy = 0
        end
    end
end

local function updateBrekingProtocol(delta)
    if BrekingProtocol.enabled then
        BrekingProtocol.coreHashTimer = BrekingProtocol.coreHashTimer + delta
        if BrekingProtocol.coreHashTimer > BrekingProtocol.traceWipeInternal then
            BrekingProtocol.anomalyInternal.patterns = {}
            BrekingProtocol.coreHashTimer = 0
            BrekingProtocol.zeroTraceInternal = true
            task.wait(0.06)
            BrekingProtocol.zeroTraceInternal = false
        end
        BrekingProtocol.funcWrapInternal = BrekingProtocol.funcWrapInternal + 1
        if BrekingProtocol.funcWrapInternal % 30 == 0 then
            if _G.getClosestTarget then
                _G.getClosestTarget = obfuscateFunction(_G.getClosestTarget)
            end
        end
    end
end

_G.AllPartsInMap = {}
_G.ValidTargetParts = {}
_G.LastScanTime = 0

local function isValidPart(part)
    if not part:IsA("BasePart") then return false end
    if part.Transparency == 1 then return false end
    if part.Anchored then return false end
    if part.Size.Magnitude < 0.5 or part.Size.Magnitude > 50 then return false end
    if string.find(part.Name:lower(), "wall") or string.find(part.Name:lower(), "floor") or string.find(part.Name:lower(), "base") then return false end
    return true
end

local function scanMap()
    _G.LastScanTime = tick()
    table.clear(_G.AllPartsInMap)
    table.clear(_G.ValidTargetParts)

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if isValidPart(obj) then
            table.insert(_G.AllPartsInMap, obj)
            local model = obj:FindFirstAncestorOfClass("Model")
            if model and model:FindFirstChildOfClass("Humanoid") then
                table.insert(_G.ValidTargetParts, obj)
            end
        end
    end
    print("[OUPI] Scan Complete | Found:", #_G.AllPartsInMap, "parts |", #_G.ValidTargetParts, "targetable parts")
end
scanMap()
task.spawn(function()
    while task.wait(8) do
        pcall(scanMap)
    end
end)

local DrawingAvailable = (typeof(Drawing) ~= "nil")
local DrawingElements = {}
local visibilityCache = {}
local cacheTimer = 0
local cacheUpdateInterval = 0.05
local isInitialized = false

local function hasLineOfSight(origin, targetCharacter, ignoreList)
    if not targetCharacter then return false end
    
    local rootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end

    local bodyPartsToScan = {"Head", "UpperTorso", "LowerTorso"}
    
    local existingParts = {}
    for _, partName in ipairs(bodyPartsToScan) do
        local part = targetCharacter:FindFirstChild(partName)
        if part then
            table.insert(existingParts, part)
        end
    end
    if #existingParts == 0 then
        local torso = targetCharacter:FindFirstChild("Torso")
        if torso then table.insert(existingParts, torso) end
    end
    if #existingParts == 0 and rootPart then
        table.insert(existingParts, rootPart)
    end


    local raySuccessCount = 0
    local totalRays = #existingParts + AntiBanSystem.wallEvasion.rayCount

    for _, part in ipairs(existingParts) do
        local partPos = part.Position
        local direction = (partPos - origin)
        local distance = direction.Magnitude

        if distance == 0 then
            raySuccessCount = raySuccessCount + 1
            continue 
        end
        
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = ignoreList or {LocalPlayer.Character}
        rayParams.IgnoreWater = true
        
        local result = Workspace:Raycast(origin, direction, rayParams)
        
        if not result then
            raySuccessCount = raySuccessCount + 1
        end
    end

    local rootPos = rootPart.Position
    for i = 1, AntiBanSystem.wallEvasion.rayCount do
        local offset = Vector3.new(
            math.random(-200, 200) / 100,
            math.random(-150, 150) / 100,
            math.random(-200, 200) / 100
        )
        local checkPos = rootPos + offset
        local direction = (checkPos - origin)
        local distance = direction.Magnitude

        if distance == 0 then continue end

        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = ignoreList or {LocalPlayer.Character}
        rayParams.IgnoreWater = true

        local result = Workspace:Raycast(origin, direction, rayParams)

        if not result then
            raySuccessCount = raySuccessCount + 1
        end
    end

    if totalRays == 0 then return false end
    
    local visibilityRatio = raySuccessCount / totalRays
    
    return visibilityRatio > AntiBanSystem.wallEvasion.occlusionThreshold
end

local function hideBox(elements)
    if elements and elements.Box then
        elements.Box.PointA = Vector2.new(0, 0)
        elements.Box.PointB = Vector2.new(0, 0)
        elements.Box.PointC = Vector2.new(0, 0)
        elements.Box.PointD = Vector2.new(0, 0)
        elements.Box.Visible = false
    end
end

local function hideTextElements(elements)
    if not elements then return end
    local offScreenPos = Vector2.new(-1000, -1000)
    if elements.Name then
        elements.Name.Position = offScreenPos
        elements.Name.Visible = false
    end
    if elements.Distance then
        elements.Distance.Position = offScreenPos
        elements.Distance.Visible = false
    end
    if elements.Weapon then
        elements.Weapon.Position = offScreenPos
        elements.Weapon.Visible = false
    end
    if elements.State then
        elements.State.Position = offScreenPos
        elements.State.Visible = false
    end
    if elements.HealthBar then
        elements.HealthBar.From = offScreenPos
        elements.HealthBar.To = offScreenPos
        elements.HealthBar.Visible = false
    end
    if elements.Tracer then
        elements.Tracer.From = offScreenPos
        elements.Tracer.To = offScreenPos
        elements.Tracer.Visible = false
    end
end

local function cleanupAllDrawings()
    for player, elements in pairs(DrawingElements) do
        if elements then
            for _, obj in pairs(elements) do
                if typeof(obj) == "Drawing" and obj.Remove then
                    pcall(obj.Remove, obj)
                elseif obj:IsA("Highlight") then
                    obj:Destroy()
                end
            end
        end
    end
    DrawingElements = {}
    visibilityCache = {}
    isInitialized = false
end

local function createDrawingForPlayer(player)
    if DrawingElements[player] then return end
    if not DrawingAvailable then return end

    local elements = {
        Box = Drawing.new("Quad"),
        Tracer = Drawing.new("Line"),
        Arrow = Drawing.new("Triangle"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBar = Drawing.new("Line"),
        Weapon = Drawing.new("Text"),
        State = Drawing.new("Text"),
        Highlight = Instance.new("Highlight"),
        Skeleton = {
            HeadToTorso = Drawing.new("Line"),
            TorsoToLegs = Drawing.new("Line"),
            LeftArm = Drawing.new("Line"),
            RightArm = Drawing.new("Line"),
            LeftLeg = Drawing.new("Line"),
            RightLeg = Drawing.new("Line")
        }
    }

    for _, obj in pairs(elements) do
        if typeof(obj) == "Drawing" then
            obj.Visible = false
        elseif type(obj) == "table" then
            for _, line in pairs(obj) do
                line.Visible = false
                line.Thickness = 1
                line.Color = Color3.fromRGB(255, 255, 255)
            end
        end
    end

    elements.Box.Filled = false
    elements.Box.Thickness = 2
    elements.Arrow.Filled = true
    elements.Name.Center = true
    elements.Name.Size = 14
    elements.Name.Font = Drawing.Fonts.UI
    elements.Distance.Center = true
    elements.Distance.Size = 12
    elements.Distance.Font = Drawing.Fonts.UI
    elements.Weapon.Center = true
    elements.Weapon.Size = 12
    elements.Weapon.Font = Drawing.Fonts.UI
    elements.State.Center = true
    elements.State.Size = 12
    elements.State.Font = Drawing.Fonts.UI
    elements.HealthBar.Thickness = 3

    elements.Highlight.FillTransparency = 1
    elements.Highlight.OutlineTransparency = 0
    elements.Highlight.Parent = Workspace

    DrawingElements[player] = elements
end

function initializeESP()
    if not DrawingAvailable then return end
    cleanupAllDrawings()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            createDrawingForPlayer(player)
        end
    end
    isInitialized = true
end

if DrawingAvailable then
    initializeESP()
end

Players.PlayerAdded:Connect(function(player)
    if player == LocalPlayer then return end
    player.CharacterAdded:Connect(function()
        task.wait(0.1)
        if DrawingElements[player] then
            for _, obj in pairs(DrawingElements[player]) do
                if typeof(obj) == "Drawing" and obj.Remove then
                    pcall(obj.Remove, obj)
                elseif obj:IsA("Highlight") then
                    obj:Destroy()
                elseif type(obj) == "table" then
                    for _, line in pairs(obj) do
                        if typeof(line) == "Drawing" and line.Remove then
                            pcall(line.Remove, line)
                        end
                    end
                end
            end
            DrawingElements[player] = nil
        end
        if DrawingAvailable then
            createDrawingForPlayer(player)
        end
    end)
    if player.Character then
        task.wait(0.1)
        if DrawingAvailable then
            createDrawingForPlayer(player)
        end
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if DrawingElements[player] then
        for _, obj in pairs(DrawingElements[player]) do
            if typeof(obj) == "Drawing" and obj.Remove then
                pcall(obj.Remove, obj)
            elseif obj:IsA("Highlight") then
                obj:Destroy()
            elseif type(obj) == "table" then
                for _, line in pairs(obj) do
                    if typeof(line) == "Drawing" and line.Remove then
                        pcall(line.Remove, line)
                    end
                end
            end
        end
        DrawingElements[player] = nil
        visibilityCache[player] = nil
    end
end)

task.spawn(function()
    while task.wait(1.5) do

        local aPlayer = Players:GetPlayers()[2] or Players:GetPlayers()[1]
        if aPlayer and aPlayer ~= LocalPlayer then
            if not DrawingElements[aPlayer] or not DrawingElements[aPlayer].Name then
                initializeESP()
            end
        elseif not isInitialized and #Players:GetPlayers() > 1 then
            initializeESP()
        end
    end
end)

local okName, gameName = pcall(function()
    return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name:lower()
end)
gameName = okName and gameName or ""

local antiBanStage2 = {
    evasionLayers = 40,
    spoofPacketQueue = {},
    behavioralMimicry = {
        humanReactionDelays = {0.08, 0.12, 0.15, 0.18, 0.22, 0.10, 0.14, 0.11, 0.16, 0.13, 0.19},
        mouseCurveVariations = {0.2, 0.3, 0.4, 0.5, 0.6, 0.25, 0.35, 0.28, 0.42, 0.32, 0.48},
        aimSmoothingProfiles = {
            {name = "natural", factor = 0.25},
            {name = "aggressive", factor = 0.4},
            {name = "cautious", factor = 0.15},
            {name = "erratic", factor = 0.3},
            {name = "precise", factor = 0.2},
            {name = "adaptive", factor = 0.22},
            {name = "stealth", factor = 0.18},
            {name = "fluid", factor = 0.26},
            {name = "subtle", factor = 0.16}
        }
    },
    detectionEvasion = {
        serverTickSync = tick(),
        lastServerSync = 0,
        syncInterval = 0.4,
        jitterBuffer = 0.0015,
        remoteCallObfuscation = true,
        propertyMutationRate = 0.00015,
        entityCloningThreshold = 0.02
    },
    rubberbandCounter = {
        positionDrift = Vector3.new(0,0,0),
        velocityVariance = 0.01,
        correctionTimer = 0,
        correctionChance = 0.0005,
        maxDrift = 0.08
    },
    networkFingerprint = {
        latencySimulation = {min = 5, max = 150},
        packetLoss = 0.0004,
        reorderChance = 0.0001,
        currentLatency = 50
    },
    behavioralAnomalyDetector = {
        shotFrequency = {},
        movementPatterns = {},
        interactionLog = {},
        anomalyThreshold = 0.88,
        resetInterval = 10
    },
    advancedNoiseGenerators = {
        perlinOctaves = 10,
        turbulence = 1.0,
        lacunarity = 2.5,
        persistence = 0.65
    },
    quantumEvasion = {
        stateTransitions = 0,
        superpositionTimer = 0,
        collapseChance = 0.0025,
        entanglementFactor = 0.045
    },
    polymorphicCode = {
        variantId = 1,
        mutationTimer = 0,
        mutationRate = 0.04,
        activeVariant = "base"
    },
    serverSideSpoof = {
        fakeEventsQueue = {},
        eventDelay = 0.01,
        batchSize = 15
    },
    clientIntegrity = {
        checksums = {},
        validationTimer = 0,
        tamperDetection = false
    },
    environmentalAdaptation = {
        gameModeDetection = gameName,
        playerDensity = #Players:GetPlayers(),
        mapComplexity = #_G.AllPartsInMap or 0,
        adaptationFactor = 1.0
    }
}

local function generateAdvancedNoise(baseSeed, octaves, lacunarity, persistence)
    local noise = 0
    local amplitude = 1
    local frequency = 1
    for i = 1, octaves do
        noise = noise + amplitude * math.noise(baseSeed * frequency, 0, 0)
        amplitude = amplitude * persistence
        frequency = frequency * lacunarity
    end
    return noise
end

local function updateBehavioralMimicry(delta)
    local profile = antiBanStage2.behavioralMimicry.aimSmoothingProfiles[math.random(1, #antiBanStage2.behavioralMimicry.aimSmoothingProfiles)]
    aimSpeedMultiplier = aimSpeedMultiplier * (1 + (profile.factor - 0.3) * delta * 18)

    local reactionDelay = antiBanStage2.behavioralMimicry.humanReactionDelays[math.random(1, #antiBanStage2.behavioralMimicry.humanReactionDelays)]
    reactionTimer = reactionTimer + delta
    if reactionTimer > reactionDelay then
        reactionTimer = 0
        reactionChance = math.random() * 0.0006
    end
end

local function syncWithServer(delta)
    antiBanStage2.detectionEvasion.lastServerSync = antiBanStage2.detectionEvasion.lastServerSync + delta
    if antiBanStage2.detectionEvasion.lastServerSync > antiBanStage2.detectionEvasion.syncInterval then
        antiBanStage2.detectionEvasion.serverTickSync = tick() + antiBanStage2.detectionEvasion.jitterBuffer * math.random(-4, 4)
        antiBanStage2.detectionEvasion.lastServerSync = 0
    end
end

local function applyRubberbandCounter(delta)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        antiBanStage2.rubberbandCounter.correctionTimer = antiBanStage2.rubberbandCounter.correctionTimer + delta
        if antiBanStage2.rubberbandCounter.correctionTimer > 0.04 then
            if math.random() < antiBanStage2.rubberbandCounter.correctionChance then
                local drift = antiBanStage2.rubberbandCounter.positionDrift + Vector3.new(
                    math.random(-antiBanStage2.rubberbandCounter.maxDrift, antiBanStage2.rubberbandCounter.maxDrift),
                    math.random(-0.1, 0.1),
                    math.random(-antiBanStage2.rubberbandCounter.maxDrift, antiBanStage2.rubberbandCounter.maxDrift)
                )
                root.CFrame = root.CFrame + drift
                antiBanStage2.rubberbandCounter.positionDrift = Vector3.new(0,0,0)
            end
            antiBanStage2.rubberbandCounter.correctionTimer = 0
        end
        root.Velocity = root.Velocity + Vector3.new(
            math.random(-antiBanStage2.rubberbandCounter.velocityVariance, antiBanStage2.rubberbandCounter.velocityVariance),
            math.random(-0.02, 0.02),
            math.random(-antiBanStage2.rubberbandCounter.velocityVariance, antiBanStage2.rubberbandCounter.velocityVariance)
        )
    end
end

local function simulateNetworkConditions(delta)
    antiBanStage2.networkFingerprint.currentLatency = antiBanStage2.networkFingerprint.currentLatency + (math.random(antiBanStage2.networkFingerprint.latencySimulation.min, antiBanStage2.networkFingerprint.latencySimulation.max) - antiBanStage2.networkFingerprint.currentLatency) * delta * 3.5
    delta = delta * (1 + antiBanStage2.networkFingerprint.currentLatency / 1000)

    if math.random() < antiBanStage2.networkFingerprint.packetLoss then
        task.wait(antiBanStage2.networkFingerprint.currentLatency / 1000 * 1.8)
    end

    if math.random() < antiBanStage2.networkFingerprint.reorderChance then
        table.insert(antiBanStage2.spoofPacketQueue, {type = "reorder", delay = math.random(0.002, 0.1)})
    end
end

local function detectAnomalies()
    local currentTime = tick()
    table.insert(antiBanStage2.behavioralAnomalyDetector.shotFrequency, currentTime - lastFireTime)
    if #antiBanStage2.behavioralAnomalyDetector.shotFrequency > 125 then
        table.remove(antiBanStage2.behavioralAnomalyDetector.shotFrequency, 1)
    end

    local avgShotInterval = 0
    for _, interval in ipairs(antiBanStage2.behavioralAnomalyDetector.shotFrequency) do
        avgShotInterval = avgShotInterval + interval
    end
    if #antiBanStage2.behavioralAnomalyDetector.shotFrequency > 0 then
        avgShotInterval = avgShotInterval / #antiBanStage2.behavioralAnomalyDetector.shotFrequency
    end

    if avgShotInterval < 0.025 and #antiBanStage2.behavioralAnomalyDetector.shotFrequency > 25 then
        backoffLevel = backoffLevel * 1.7
        print("[Anomaly Detected] Adjusting backoff for rapid firing")
    end
end

local function updateAdvancedNoise(delta)
    polyTimer = polyTimer + delta
    local advancedNoise = generateAdvancedNoise(polyTimer, antiBanStage2.advancedNoiseGenerators.perlinOctaves, antiBanStage2.advancedNoiseGenerators.lacunarity, antiBanStage2.advancedNoiseGenerators.persistence)
    currentNoise = currentNoise + Vector3.new(
        advancedNoise * maxNoise * 1.8,
        advancedNoise * maxNoise * 1.0,
        advancedNoise * maxNoise * 1.8
    )
end

local function quantumEvasionUpdate(delta)
    antiBanStage2.quantumEvasion.superpositionTimer = antiBanStage2.quantumEvasion.superpositionTimer + delta
    if antiBanStage2.quantumEvasion.superpositionTimer > 0.04 then
        if math.random() < antiBanStage2.quantumEvasion.collapseChance then
            antiBanStage2.quantumEvasion.stateTransitions = antiBanStage2.quantumEvasion.stateTransitions + 1
            if antiBanStage2.quantumEvasion.stateTransitions % 1 == 0 then
                aimSpeedMultiplier = aimSpeedMultiplier * (1 + antiBanStage2.quantumEvasion.entanglementFactor * 1.8)
            end
        end
        antiBanStage2.quantumEvasion.superpositionTimer = 0
    end
end

local function mutatePolymorphicCode(delta)
    antiBanStage2.polymorphicCode.mutationTimer = antiBanStage2.polymorphicCode.mutationTimer + delta
    if antiBanStage2.polymorphicCode.mutationTimer > antiBanStage2.polymorphicCode.mutationRate then
        antiBanStage2.polymorphicCode.variantId = antiBanStage2.polymorphicCode.variantId + 1
        if antiBanStage2.polymorphicCode.variantId > 25 then
            antiBanStage2.polymorphicCode.variantId = 1
        end
        antiBanStage2.polymorphicCode.activeVariant = "variant_" .. antiBanStage2.polymorphicCode.variantId
        maxNoise = maxNoise * (1 + math.random(-0.025, 0.025))
        antiBanStage2.polymorphicCode.mutationTimer = 0
    end
end

local function spoofServerEvents()
    if #antiBanStage2.serverSideSpoof.fakeEventsQueue < antiBanStage2.serverSideSpoof.batchSize then
        table.insert(antiBanStage2.serverSideSpoof.fakeEventsQueue, {
            type = "movement",
            data = {
                x = math.random(-4,4),
                y = math.random(-2,2),
                z = math.random(-4,4)
            },
            delay = antiBanStage2.serverSideSpoof.eventDelay + math.random(-0.01, 0.01)
        })
    end
    if #antiBanStage2.serverSideSpoof.fakeEventsQueue > 0 then
        local event = table.remove(antiBanStage2.serverSideSpoof.fakeEventsQueue, 1)
        task.spawn(function()
            task.wait(event.delay)
            if LocalPlayer.Character then
                local root = LocalPlayer.Character.HumanoidRootPart
                if root then
                    root.CFrame = root.CFrame + Vector3.new(event.data.x * 0.025, event.data.y * 0.02, event.data.z * 0.025)
                end
            end
        end)
    end
end

local function checkClientIntegrity()
    antiBanStage2.clientIntegrity.validationTimer = antiBanStage2.clientIntegrity.validationTimer + 1
    if antiBanStage2.clientIntegrity.validationTimer > 20 then
        local checksum = 0
        for k, v in pairs(antiBanStage2) do
            if type(v) == "number" then
                checksum = checksum + v
            end
        end
        if not antiBanStage2.clientIntegrity.checksums[checksum] then
            antiBanStage2.clientIntegrity.tamperDetection = true
            print("[Integrity Alert] Potential tampering detected - Resetting parameters")
            backoffLevel = 1
            aimSpeedMultiplier = 1
        end
        antiBanStage2.clientIntegrity.checksums[checksum] = true
        antiBanStage2.clientIntegrity.validationTimer = 0
    end
end

local function adaptToEnvironment()
    local currentPlayers = #Players:GetPlayers()
    local densityChange = (currentPlayers - antiBanStage2.environmentalAdaptation.playerDensity) / 10
    antiBanStage2.environmentalAdaptation.adaptationFactor = antiBanStage2.environmentalAdaptation.adaptationFactor * (1 + densityChange * 0.025)
    antiBanStage2.environmentalAdaptation.playerDensity = currentPlayers

    if #_G.AllPartsInMap > 0 then
        local complexity = #_G.AllPartsInMap / 1000
        thresholdSensitivity = thresholdSensitivity * (1 + complexity * 0.0025)
    end
end

local stage2Connection = RunService.Heartbeat:Connect(function(delta)
    if protectionAlphaEnabled or protectionBetaEnabled or protectionGammaEnabled then
        pcall(updateBehavioralMimicry, delta)
        pcall(syncWithServer, delta)
        pcall(applyRubberbandCounter, delta)
        pcall(simulateNetworkConditions, delta)
        pcall(updateAdvancedNoise, delta)
        pcall(quantumEvasionUpdate, delta)
        pcall(mutatePolymorphicCode, delta)
        pcall(spoofServerEvents)
        pcall(checkClientIntegrity)
        pcall(adaptToEnvironment)
        pcall(updatePolymorphic, delta)
        pcall(updateMetamorphic, delta)
        pcall(updateObfuscation, delta)
        pcall(updateFakeTrails, delta)
        pcall(updateEntropyShield, delta)

        if ProtectionSystem and ProtectionSystem.Alpha and ProtectionSystem.Alpha.enabled then
            pcall(ProtectionSystem.Alpha.update, delta)
        end
        if ProtectionSystem and ProtectionSystem.Beta and ProtectionSystem.Beta.enabled then
            pcall(ProtectionSystem.Beta.update, delta)
        end
        if ProtectionSystem and ProtectionSystem.Gamma and ProtectionSystem.Gamma.enabled then
            pcall(ProtectionSystem.Gamma.update, delta)
        end

        if tick() % 2 < delta then
            pcall(detectAnomalies)
        end

        if integrityCheckTimer > AntiBanSystem.detectionShield.hashInterval / 4 then
            pcall(enhancedIntegrityCheck)
            integrityCheckTimer = 0
        end
        integrityCheckTimer = integrityCheckTimer + delta

        pcall(updateYamaProtocol, delta)
        pcall(updateToshitaProtocol, delta)
        pcall(updateEndlisProtocol, delta)
        pcall(updateHedlisProtocol, delta)
        pcall(updateBrekingProtocol, delta)
    end
end)

local stickyEnabled = false
local stickyDuration = 2
local lastTargetData = nil
local stickyTime = 0

local showAimLine = false
local targetLine = Drawing.new("Line")
targetLine.Color = Color3.new(0, 1, 0)
targetLine.Thickness = 2
targetLine.Transparency = 1

local currentFps = 60
local fpsSamples = {}
local fpsSampleCount = 30

local FOVCircleDrawing = nil
local bodyVelocity = nil

local function createBodyVelocity()
    if bodyVelocity then bodyVelocity:Destroy() end
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function updateAirWalk()
    if not airWalkEnabled or not LocalPlayer.Character then return end
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not root or not humanoid then return end
    humanoid.PlatformStand = true
    if not bodyVelocity or bodyVelocity.Parent ~= root then
        createBodyVelocity()
    end
    local camLook = Camera.CFrame.LookVector
    local camRight = Camera.CFrame.RightVector
    local moveVector = (camLook * (keys.w - keys.s)) + (camRight * (keys.d - keys.a)) + Vector3.new(0, (keys.e - keys.q), 0)
    bodyVelocity.Velocity = moveVector * flySpeed * HedlisProtocol.velocityShield
end

local keys = {a = 0, d = 0, w = 0, s = 0, q = 0, e = 0}

local boostEnabled = { speed = false, jump = false }
local boostValues = { speed = 50, jump = 100 }
local defaultValues = { speed = 16, jump = { height = 7.2, power = 50 } }
local spoofTimers = { speed = 0, jump = 0 }
local resetIntervals = { speed = 0.1, jump = 0.15 }
local resetChances = { speed = 0.004, jump = 0.003 }
local noises = { speed = 0, jump = 0 }
local protectionTimers = { speed = 0, jump = 0 }

local infJumpEnabled = false

local autoBhopEnabled = false

local airWalkEnabled = false
local flySpeed = 50

local hitboxProtectionEnabled = true
local hitboxResetInterval = 0.1
local hitboxNoiseChance = 0.0015

local TeamCheck = {}

TeamCheck.Settings = {
    AimbotTeamCheck = true,
    ESPTeamCheck = true,

    AutoDetectMode = {
        Enabled = true,
        CurrentGameMode = "UNKNOWN",
        CheckInterval = 5,
        
        TDM_Threshold = 0.4,
        FFA_Threshold = 0.8,
    }
}

function TeamCheck:isEnemy(targetPlayer)
    if not targetPlayer or targetPlayer == LocalPlayer then return false end

    if not LocalPlayer.Team or not targetPlayer.Team then
        return true
    end

    if LocalPlayer.Team == targetPlayer.Team then
        return false
    end

    if targetPlayer.Neutral and LocalPlayer.Neutral then
        return false
    end
    
    local pLeaderstats = LocalPlayer:FindFirstChild("leaderstats")
    local tLeaderstats = targetPlayer:FindFirstChild("leaderstats")
    if pLeaderstats and tLeaderstats then
        local teamStat = tLeaderstats:FindFirstChild("Team")
        if teamStat then
            local localTeamStat = pLeaderstats:FindFirstChild("Team")
            if localTeamStat and teamStat.Value == localTeamStat.Value then
                return false
            end
        end
    end

    local teamAttribute = targetPlayer:GetAttribute("Team")
    if teamAttribute then
        local localTeamAttribute = LocalPlayer:GetAttribute("Team")
        if localTeamAttribute and teamAttribute == localTeamAttribute then
            return false
        end
    end

    return true
end

task.spawn(function()
    while true do
        task.wait(TeamCheck.Settings.AutoDetectMode.Enabled and TeamCheck.Settings.AutoDetectMode.CheckInterval or 1)

        if not TeamCheck.Settings.AutoDetectMode.Enabled then continue end

        pcall(function()
            local players = Players:GetPlayers()
            local totalPlayers = #players
            if totalPlayers < 2 then return end

            local playersInTeams = 0
            local playersWithoutTeams = 0
            local teams = {}

            for _, player in ipairs(players) do
                if player.Team then
                    playersInTeams = playersInTeams + 1
                    teams[player.Team] = (teams[player.Team] or 0) + 1
                else
                    playersWithoutTeams = playersWithoutTeams + 1
                end
            end

            local oldMode = TeamCheck.Settings.AutoDetectMode.CurrentGameMode
            local newMode = "TDM"

            if (playersWithoutTeams / totalPlayers) >= TeamCheck.Settings.AutoDetectMode.FFA_Threshold then
                newMode = "FFA"
            elseif #players == playersWithoutTeams then
                 newMode = "FFA"
            elseif playersInTeams > 0 and #teams > 2 then
                newMode = "MULTI-TEAM"
            else
                newMode = "TDM"
            end

            if newMode ~= oldMode then
                TeamCheck.Settings.AutoDetectMode.CurrentGameMode = newMode
                print("[Auto Team Check] Game mode changed to: " .. newMode)

                if newMode == "FFA" then
                    TeamCheck.Settings.AimbotTeamCheck = false
                    TeamCheck.Settings.ESPTeamCheck = false
                    Rayfield:Notify({ Title = "Auto Team Check", Content = "FFA Mode Detected. Team checks are OFF.", Duration = 4 })
                else
                    TeamCheck.Settings.AimbotTeamCheck = true
                    TeamCheck.Settings.ESPTeamCheck = true
                    Rayfield:Notify({ Title = "Auto Team Check", Content = "Team Mode Detected. Team checks are ON.", Duration = 4 })
                end
            end
        end)
    end
end)

local noclipEnabled = false
local noclipConnection

local predictionMultipliers = {
    ["arsenal"] = {velocityDamp = 0.7, timeFactor = 0.23},
    ["phantom forces"] = {velocityDamp = 0.4, timeFactor = 0.26},
    ["bad business"] = {velocityDamp = 0.5, timeFactor = 0.2},
    ["big paintball!"] = {velocityDamp = 0.6, timeFactor = 0.1},
    ["blackhawk rescue mission 5"] = {velocityDamp = 0.3, timeFactor = 0.3},
    ["rivals"] = {velocityDamp = 0.45, timeFactor = 0.23},
    ["weird gun game"] = {velocityDamp = 0.65, timeFactor = 0.13},
    ["zombie uprising"] = {velocityDamp = 0.55, timeFactor = 0.18},
    ["island royale"] = {velocityDamp = 0.4, timeFactor = 0.26},
    ["counter blox"] = {velocityDamp = 0.45, timeFactor = 0.23},
    ["deathrun"] = {velocityDamp = 0.75, timeFactor = 0.08},
    ["jailbreak"] = {velocityDamp = 0.35, timeFactor = 0.28},
    ["mad city"] = {velocityDamp = 0.5, timeFactor = 0.2},
    ["natural disaster survival"] = {velocityDamp = 0.65, timeFactor = 0.13},
    ["adopt me!"] = {velocityDamp = 0.6, timeFactor = 0.16},
    ["blox fruits"] = {velocityDamp = 0.45, timeFactor = 0.23},
    ["pet simulator x"] = {velocityDamp = 0.55, timeFactor = 0.18},
    ["murder mystery 2"] = {velocityDamp = 0.4, timeFactor = 0.26},
    ["royale high"] = {velocityDamp = 0.7, timeFactor = 0.1},
    ["meepcity"] = {velocityDamp = 0.75, timeFactor = 0.08},
    ["work at a pizza place"] = {velocityDamp = 0.5, timeFactor = 0.2},
    ["theme park tycoon 2"] = {velocityDamp = 0.65, timeFactor = 0.13},
    ["welcome to bloxburg"] = {velocityDamp = 0.6, timeFactor = 0.16},
}

local okName, gameName = pcall(function()
    return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name:lower()
end)
gameName = okName and gameName or ""

local HephaestusProtocol = {
    learningRate = 0.008,
    shotsToAnalyze = 15,
    errorThreshold = 0.15,
    maxTimeFactor = 0.35,
    minTimeFactor = 0.05,
    shotHistory = {},
    predictionError = 0,
    learnedMultiplier = { velocityDamp = 0.72, timeFactor = 0.12 }
}
local gameBaseMultiplier = predictionMultipliers[gameName] or {velocityDamp = 0.55, timeFactor = 0.18}
HephaestusProtocol.learnedMultiplier.velocityDamp = (gameBaseMultiplier.velocityDamp or 0.55)
HephaestusProtocol.learnedMultiplier.timeFactor = (gameBaseMultiplier.timeFactor or 0.18)

local currentMultiplier = HephaestusProtocol.learnedMultiplier

task.spawn(function()
    while true do
        task.wait(1)
        lastAntiCheatCheck = tick()
        local antiCheatObjects = {"AntiCheat", "ExploitDetector", "ScriptGuard", "BanSystem", "DetectionModule", "Byfron", "Hyperion", "Adonis", "IntegrityCheck", "Vanguard", "Spectre", "Guardian"}
        for _, objName in ipairs(antiCheatObjects) do
            if game:GetService("ReplicatedStorage"):FindFirstChild(objName) or game:GetService("ServerScriptService"):FindFirstChild(objName) or Workspace:FindFirstChild(objName) then
                antiCheatDetection = true
                for i = 1, 50 do
                    task.wait(math.random(0.005, 0.04))
                    currentNoise = currentNoise + Vector3.new(math.random(-0.1, 0.1), math.random(-0.05, 0.05), math.random(-0.1, 0.1))
                    aimSpeedMultiplier = aimSpeedMultiplier * (1 + math.random(-0.02, 0.02))
                    if i % 1 == 0 then
                        backoffLevel = math.min(backoffLevel + 0.04, 1.5)
                        AntiBanSystem.polymorphicEngine.mutationTimer = AntiBanSystem.polymorphicEngine.mutationRate - 1
                        AntiBanSystem.metamorphicEngine.morphTimer = AntiBanSystem.metamorphicEngine.morphRate - 1
                    end
                end
                AntiBanSystem.zeroTraceMode = true
                task.wait(1)
                AntiBanSystem.zeroTraceMode = false
                break
            end
        end
        antiCheatDetection = false
    end
end)

local function GenericBoostHandler(boostType, delta)
    if not LocalPlayer.Character then return end
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not root then return end

    local gameTime = tick()
    local enabled = boostEnabled[boostType]
    local value = boostValues[boostType]
    local default = defaultValues[boostType]
    local spoofTimer = spoofTimers[boostType]
    local resetInterval = resetIntervals[boostType]
    local resetChance = resetChances[boostType]
    local noise = noises[boostType]
    local protectionTimer = protectionTimers[boostType]

    if enabled then
        local noiseScale = 0.45
        noise = math.sin(gameTime * (boostType == "speed" and 11 or 10)) * noiseScale + math.random(-noiseScale, noiseScale)
        if AntiBanSystem.zeroTraceMode then
            noise = noise * 0.2
        end
        local targetValue = value + noise * HedlisProtocol.velocityShield
        local isJump = boostType == "jump"
        local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15

        if boostType == "speed" then
            humanoid.WalkSpeed = math.clamp(targetValue, default, value * 1.25)
        else
            local prop = isR15 and "JumpHeight" or "JumpPower"
            local defVal = isR15 and default.height or default.power
            humanoid[prop] = math.clamp(targetValue, defVal, value * 1.25)
        end

        spoofTimer = spoofTimer + delta
        if spoofTimer > 0.0005 then
            local oldPos = root.Position
            local offset = Vector3.new(math.random(-0.1, 0.1), math.random(-0.04, 0.04), math.random(-0.1, 0.1))
            root.CFrame = root.CFrame + offset
            root.Position = oldPos
            spoofTimer = 0
        end

        if gameTime % (isJump and 0.12 or 0.05) < delta then
            local resetVal = boostType == "speed" and default + math.random(-0.25, 0.25) or (isR15 and default.height + math.random(-0.25, 0.25) or default.power + math.random(-0.35, 0.35))
            if boostType == "speed" then
                humanoid.WalkSpeed = resetVal
            else
                local prop = isR15 and "JumpHeight" or "JumpPower"
                humanoid[prop] = resetVal
            end
            task.wait(0.0005)
            if boostType == "speed" then
                humanoid.WalkSpeed = targetValue
            else
                local prop = isR15 and "JumpHeight" or "JumpPower"
                humanoid[prop] = targetValue
            end
        end

        if math.random() < (isJump and 0.01 or 0.011) then
            local resetVal = boostType == "speed" and default + math.random(-1, 1) or (isR15 and default.height + math.random(-0.35, 0.35) or default.power + math.random(-0.45, 0.45))
            if boostType == "speed" then
                humanoid.WalkSpeed = resetVal
            else
                local prop = isR15 and "JumpHeight" or "JumpPower"
                humanoid[prop] = resetVal
            end
            task.wait(0.003)
            if boostType == "speed" then
                humanoid.WalkSpeed = targetValue
            else
                local prop = isR15 and "JumpHeight" or "JumpPower"
                humanoid[prop] = targetValue
            end
        end

        protectionTimer = protectionTimer + delta
        if protectionTimer > (isJump and 0.025 or 0.035) then
            local microAdjust = math.random(-0.25, 0.25)
            if boostType == "speed" then
                humanoid.WalkSpeed = humanoid.WalkSpeed + microAdjust
            else
                local prop = isR15 and "JumpHeight" or "JumpPower"
                humanoid[prop] = humanoid[prop] + microAdjust
            end
            protectionTimer = 0
        end
    else
        if boostType == "speed" then
            humanoid.WalkSpeed = default
        else
            local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
            local prop = isR15 and "JumpHeight" or "JumpPower"
            local defVal = isR15 and default.height or default.power
            humanoid[prop] = defVal
        end
    end

    noises[boostType] = noise
    spoofTimers[boostType] = spoofTimer
    protectionTimers[boostType] = protectionTimer
end

local unifiedBoostConnection = RunService.Heartbeat:Connect(function(delta)
    Aegis:SafeRun("PlayerMods", function()
        table.insert(fpsSamples, 1 / delta)
        if #fpsSamples > fpsSampleCount then
            table.remove(fpsSamples, 1)
        end
        local fpsSum = 0
        for _, sample in ipairs(fpsSamples) do
            fpsSum = fpsSum + sample
        end
        currentFps = fpsSum / #fpsSamples

        if Aegis.Enabled and currentFps < Aegis.Performance.FPSThreshold and not Aegis.Performance.IsThrottled then
            Aegis.Performance.IsThrottled = true
            warn("[Aegis] Performance throttled due to low FPS.")
        elseif Aegis.Performance.IsThrottled and currentFps > Aegis.Performance.FPSThreshold + 5 then
            Aegis.Performance.IsThrottled = false
            warn("[Aegis] Performance restored.")
        end

        if Aegis.Performance.IsThrottled then return end

        if boostEnabled.speed then
            GenericBoostHandler("speed", delta)
        end
        if boostEnabled.jump then
            GenericBoostHandler("jump", delta)
        end
        if autoBhopEnabled and LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.MoveDirection.Magnitude > 0 and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                humanoid.Jump = true
            end
        end
        updateAirWalk()
        if not airWalkEnabled and bodyVelocity then
            bodyVelocity:Destroy()
            bodyVelocity = nil
        end
    end, delta)
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.A then keys.a = 1
    elseif key == Enum.KeyCode.D then keys.d = 1
    elseif key == Enum.KeyCode.W then keys.w = 1
    elseif key == Enum.KeyCode.S then keys.s = 1
    elseif key == Enum.KeyCode.Q then keys.q = 1
    elseif key == Enum.KeyCode.E then keys.e = 1
    end
end)

UserInputService.InputEnded:Connect(function(input)
    local key = input.KeyCode
    if key == Enum.KeyCode.A then keys.a = 0
    elseif key == Enum.KeyCode.D then keys.d = 0
    elseif key == Enum.KeyCode.W then keys.w = 0
    elseif key == Enum.KeyCode.S then keys.s = 0
    elseif key == Enum.KeyCode.Q then keys.q = 0
    elseif key == Enum.KeyCode.E then keys.e = 0
    end
end)

UserInputService.JumpRequest:Connect(function()
    if infJumpEnabled then
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            if math.random() < 0.04 then
                local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if root then
                    root.Velocity = root.Velocity + Vector3.new(math.random(-0.35, 0.35), 0, math.random(-0.35, 0.35)) * HedlisProtocol.velocityShield
                end
            end
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed or not infJumpEnabled then return end
    if input.KeyCode == Enum.KeyCode.Space then
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            if math.random() < 0.04 then
                local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if root then
                    root.Velocity = root.Velocity + Vector3.new(math.random(-0.35, 0.35), 0, math.random(-0.35, 0.35)) * HedlisProtocol.velocityShield
                end
            end
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    defaultValues.speed = char.Humanoid.WalkSpeed or 16
    local isR15 = char.Humanoid.RigType == Enum.HumanoidRigType.R15
    defaultValues.jump.height = isR15 and (char.Humanoid.JumpHeight or 7.2) or nil
    defaultValues.jump.power = isR15 and nil or (char.Humanoid.JumpPower or 50)
    task.wait(0.02)
    if boostEnabled.speed then
        char.Humanoid.WalkSpeed = boostValues.speed * HedlisProtocol.velocityShield
    end
    if boostEnabled.jump then
        local isR15 = char.Humanoid.RigType == Enum.HumanoidRigType.R15
        local prop = isR15 and "JumpHeight" or "JumpPower"
        char.Humanoid[prop] = boostValues.jump * HedlisProtocol.jumpBackoff
    end
    if airWalkEnabled then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.PlatformStand = true
        end
        task.wait(0.1)
        createBodyVelocity()
    end
end)

local Aimbot = Window:CreateTab("Aimbot")
Aimbot:CreateToggle({
    Name = "Aimbot ON/OFF",
    CurrentValue = aimbotEnabled,
    Callback = function(Value)
        aimbotEnabled = Value
        Rayfield:Notify({
            Title = "Aimbot",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
Aimbot:CreateSlider({
    Name = "Aimbot Speed (0 - 1.5)",
    Range = {0,1.5},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = aimbotSpeed,
    Callback = function(Value)
        aimbotSpeed = Value
    end
})
Aimbot:CreateSlider({
    Name = "Aimbot Distance (studs)",
    Range = {50,3000},
    Increment = 10,
    Suffix = "studs",
    CurrentValue = aimbotMaxDistance,
    Callback = function(Value)
        aimbotMaxDistance = Value
    end
})
Aimbot:CreateToggle({
    Name = "Wall Check (On/Off) - Ultra Enhanced",
    CurrentValue = aimbotWallCheck,
    Callback = function(Value)
        aimbotWallCheck = Value
        Rayfield:Notify({
            Title = "Wall Check",
            Content = Value and "Ultra Multi-Ray Enabled (Handles Trees/Branches)" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
Aimbot:CreateToggle({
    Name = "Auto Team Check System",
    CurrentValue = TeamCheck.Settings.AutoDetectMode.Enabled,
    Callback = function(Value)
        TeamCheck.Settings.AutoDetectMode.Enabled = Value
        if not Value then
            print("[Auto Team Check] System disabled. Control is now manual.")
        else
            print("[Auto Team Check] System enabled. Will now detect game mode.")
        end
    end
})
Aimbot:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "UpperTorso", "LowerTorso", "HumanoidRootPart", "Random"},
    CurrentOption = {"Head"},
    MultipleOptions = false,
    Callback = function(Value)
        targetPart = Value[1]
    end
})

Aimbot:CreateToggle({
    Name = "Sticky Aim (seconds after FOV)",
    CurrentValue = stickyEnabled,
    Callback = function(Value)
        stickyEnabled = Value
        Rayfield:Notify({
            Title = "Sticky Aim",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
Aimbot:CreateSlider({
    Name = "Sticky Duration (s)",
    Range = {1, 7},
    Increment = 0.5,
    Suffix = "s",
    CurrentValue = stickyDuration,
    Callback = function(Value)
        stickyDuration = Value
    end
})

Aimbot:CreateToggle({
    Name = "Show Aim Line to Target",
    CurrentValue = showAimLine,
    Callback = function(Value)
        showAimLine = Value
    end
})
Aimbot:CreateToggle({
    Name = "Triggerbot/Auto Fire ON/OFF (PC Only)",
    CurrentValue = triggerbotEnabled,
    Callback = function(Value)
        triggerbotEnabled = Value
        lastFireTime = 0
        Rayfield:Notify({
            Title = "Triggerbot",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})

local autofireKey = Enum.KeyCode.RightControl
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == autofireKey then
        triggerbotEnabled = not triggerbotEnabled
        lastFireTime = 0
        Rayfield:Notify({
            Title = "Triggerbot (Direct PC Bind)",
            Content = triggerbotEnabled and "Enabled" or "Disabled",
            Duration = 3,
            Image = triggerbotEnabled and 4483362458 or 4483362741
        })
    end
end)

Aimbot:CreateKeybind({
    Name = "Autofire Keybind (Fallback)",
    CurrentKeybind = "RightControl",
    HoldToInteract = false,
    Callback = function(Keybind)
        
    end,
})
Aimbot:CreateSlider({
    Name = "Fire Delay (seconds)",
    Range = {0.01, 1},
    Increment = 0.01,
    Suffix = "s",
    CurrentValue = fireDelay,
    Callback = function(Value)
        fireDelay = Value
    end
})
Aimbot:CreateToggle({
    Name = "FOV Circle (On/Off)",
    CurrentValue = fovEnabled,
    Callback = function(Value)
        fovEnabled = Value
        if FOVCircleDrawing then
            FOVCircleDrawing.Visible = fovEnabled
        end
    end
})
Aimbot:CreateSlider({
    Name = "FOV Size (px)",
    Range = {20,1500},
    Increment = 1,
    Suffix = "px",
    CurrentValue = fovRadius,
    Callback = function(Value)
        fovRadius = Value
        if FOVCircleDrawing then
            FOVCircleDrawing.Radius = fovRadius
        end
    end
})

local ESPTab_v3 = Window:CreateTab("ESP")

local ESPSettings = {
    Enabled = true,
    ShowBoxes = true,
    ShowGlow = false,
    ShowTracers = false,
    ShowArrows = true,
    ShowNames = true,
    ShowDistance = true,
    ShowHealthBars = true,
    ShowWeapon = false,
    ShowState = false,
    ShowSkeleton = false,
    VisibleColor = Color3.fromRGB(0, 162, 255),
    OccludedColor = Color3.fromRGB(0, 162, 255),
    TracerColor = Color3.fromRGB(255, 255, 255),
    ArrowColor = Color3.fromRGB(255, 255, 0),
    MaxDistance = 1000,
}

ESPTab_v3:CreateToggle({Name = "Enable ESP", CurrentValue = ESPSettings.Enabled, Callback = function(Value)
    ESPSettings.Enabled = Value
    Rayfield:Notify({
        Title = "ESP",
        Content = Value and "Enabled" or "Disabled",
        Duration = 3,
        Image = Value and 4483362458 or 4483362741
    })
end})
ESPTab_v3:CreateToggle({
    Name = "Auto Team Check System",
    CurrentValue = TeamCheck.Settings.AutoDetectMode.Enabled,
    Callback = function(Value)
        TeamCheck.Settings.AutoDetectMode.Enabled = Value
        if not Value then
            print("[Auto Team Check] System disabled. Control is now manual.")
        else
            print("[Auto Team Check] System enabled. Will now detect game mode.")
        end
    end
})
ESPTab_v3:CreateSlider({Name = "Max Distance", Range = {100, 5000}, Increment = 50, CurrentValue = ESPSettings.MaxDistance, Callback = function(Value)
    ESPSettings.MaxDistance = Value
end})
ESPTab_v3:CreateSection("Display Options")
ESPTab_v3:CreateToggle({
    Name = "Show Boxes",
    CurrentValue = ESPSettings.ShowBoxes,
    Callback = function(Value)
        ESPSettings.ShowBoxes = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Glow/Outline",
    CurrentValue = ESPSettings.ShowGlow,
    Callback = function(Value)
        ESPSettings.ShowGlow = Value
        if Value then
            Rayfield:Notify({Title = "Glow ESP", Content = "Enabled - Outline around enemies", Duration = 3})
        end
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Tracers",
    CurrentValue = ESPSettings.ShowTracers,
    Callback = function(Value)
        ESPSettings.ShowTracers = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Arrows (Off-screen)",
    CurrentValue = ESPSettings.ShowArrows,
    Callback = function(Value)
        ESPSettings.ShowArrows = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Names",
    CurrentValue = ESPSettings.ShowNames,
    Callback = function(Value)
        ESPSettings.ShowNames = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Distance",
    CurrentValue = ESPSettings.ShowDistance,
    Callback = function(Value)
        ESPSettings.ShowDistance = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Health Bars",
    CurrentValue = ESPSettings.ShowHealthBars,
    Callback = function(Value)
        ESPSettings.ShowHealthBars = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Weapon",
    CurrentValue = ESPSettings.ShowWeapon,
    Callback = function(Value)
        ESPSettings.ShowWeapon = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show State",
    CurrentValue = ESPSettings.ShowState,
    Callback = function(Value)
        ESPSettings.ShowState = Value
    end
})
ESPTab_v3:CreateToggle({
    Name = "Show Skeleton (Enhanced Accuracy)",
    CurrentValue = ESPSettings.ShowSkeleton,
    Callback = function(Value)
        ESPSettings.ShowSkeleton = Value
        Rayfield:Notify({
            Title = "Skeleton ESP",
            Content = Value and "Enabled - Precise body lines" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
ESPTab_v3:CreateSection("Color Options")
ESPTab_v3:CreateColorPicker({
    Name = "Visible Color",
    Color = ESPSettings.VisibleColor,
    Callback = function(Value)
        ESPSettings.VisibleColor = Value
    end
})
ESPTab_v3:CreateColorPicker({
    Name = "Occluded Color (Behind Wall)",
    Color = ESPSettings.OccludedColor,
    Callback = function(Value)
        ESPSettings.OccludedColor = Value
    end
})
ESPTab_v3:CreateColorPicker({
    Name = "Tracer Color",
    Color = ESPSettings.TracerColor,
    Callback = function(Value)
        ESPSettings.TracerColor = Value
    end
})
ESPTab_v3:CreateColorPicker({
    Name = "Arrow Color",
    Color = ESPSettings.ArrowColor,
    Callback = function(Value)
        ESPSettings.ArrowColor = Value
    end
})

RunService.Heartbeat:Connect(function(delta)
    Aegis:SafeRun("ESP", function()
        if not DrawingAvailable then return end
        cacheTimer = cacheTimer + delta
        local updateCache = cacheTimer >= cacheUpdateInterval
        local espVisible = ESPSettings.Enabled

        local viewportSize = Camera.ViewportSize

        for player, elements in pairs(DrawingElements) do
            if not elements then continue end
            if not espVisible then
                for _, obj in pairs(elements) do
                    if typeof(obj) == "Drawing" then
                        obj.Visible = false
                    elseif type(obj) == "table" then
                        for _, line in pairs(obj) do
                            line.Visible = false
                        end
                    end
                end
                if elements.Highlight then
                    elements.Highlight.Enabled = false
                end
                hideBox(elements)
                hideTextElements(elements)
                continue
            end

            if TeamCheck.Settings.ESPTeamCheck and not TeamCheck:isEnemy(player) then
                for _, obj in pairs(elements) do
                    if typeof(obj) == "Drawing" then
                        obj.Visible = false
                    elseif type(obj) == "table" then
                        for _, line in pairs(obj) do
                            line.Visible = false
                        end
                    end
                end
                if elements.Highlight then
                    elements.Highlight.Enabled = false
                end
                hideBox(elements)
                hideTextElements(elements)
                continue
            end

            local character = player.Character
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local head = character and character:FindFirstChild("Head")
            local upperTorso = character and character:FindFirstChild("UpperTorso")
            local lowerTorso = character and character:FindFirstChild("LowerTorso")
            local torso = character and character:FindFirstChild("Torso")
            local leftArm = character and character:FindFirstChild("Left Arm")
            local rightArm = character and character:FindFirstChild("Right Arm")
            local leftLeg = character and character:FindFirstChild("Left Leg")
            local rightLeg = character and character:FindFirstChild("Right Leg")

            if not (character and humanoid and rootPart and humanoid.Health > 0) then
                for _, obj in pairs(elements) do
                    if typeof(obj) == "Drawing" then
                        obj.Visible = false
                    elseif type(obj) == "table" then
                        for _, line in pairs(obj) do
                            line.Visible = false
                        end
                    end
                end
                if elements.Highlight then
                    elements.Highlight.Enabled = false
                end
                hideBox(elements)
                hideTextElements(elements)
                continue
            end

            if elements.Highlight.Adornee ~= character then
                elements.Highlight.Adornee = character
            end

            local headPos = head and head.Position or (rootPart.Position + Vector3.new(0, 3, 0))

            local distance = (Camera.CFrame.Position - rootPart.Position).Magnitude
            if distance > ESPSettings.MaxDistance then
                for _, obj in pairs(elements) do
                    if typeof(obj) == "Drawing" then
                        obj.Visible = false
                    elseif type(obj) == "table" then
                        for _, line in pairs(obj) do
                            line.Visible = false
                        end
                    end
                end
                if elements.Highlight then
                    elements.Highlight.Enabled = false
                end
                hideBox(elements)
                hideTextElements(elements)
                continue
            end

            local cacheKey = tostring(player)
            if updateCache then
                visibilityCache[cacheKey] = hasLineOfSight(Camera.CFrame.Position, character, {LocalPlayer.Character, character})
            end
            local isVisible = visibilityCache[cacheKey] or true
            local currentColor = isVisible and ESPSettings.VisibleColor or ESPSettings.OccludedColor
            local alpha = math.clamp(1 - distance / ESPSettings.MaxDistance, 0.3, 1)

            local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)

            local yOffset = 0

            if onScreen then
                local strongBlue = Color3.fromRGB(0, 162, 255)
                if ESPSettings.ShowGlow then
                    elements.Highlight.Adornee = character
                    elements.Highlight.Enabled = true
                    elements.Highlight.OutlineColor = strongBlue
                    elements.Highlight.FillColor = strongBlue
                    elements.Highlight.OutlineTransparency = 0 + EndlisProtocol.highlightDrift
                    elements.Highlight.FillTransparency = 0.9
                else
                    elements.Highlight.Enabled = false
                end

                if ESPSettings.ShowNames then
                    elements.Name.Text = player.Name
                    elements.Name.Color = currentColor
                    elements.Name.Position = Vector2.new(screenPos.X, screenPos.Y + yOffset)
                    elements.Name.Visible = true
                    yOffset = yOffset + 15
                else
                    elements.Name.Visible = false
                end
                if ESPSettings.ShowDistance then
                    elements.Distance.Text = math.floor(distance) .. "m"
                    elements.Distance.Color = currentColor
                    elements.Distance.Position = Vector2.new(screenPos.X, screenPos.Y + yOffset)
                    elements.Distance.Visible = true
                    yOffset = yOffset + 15
                else
                    elements.Distance.Visible = false
                end
                if ESPSettings.ShowWeapon then
                    local tool = character:FindFirstChildOfClass("Tool")
                    elements.Weapon.Text = tool and tool.Name or "N/A"
                    elements.Weapon.Color = currentColor
                    elements.Weapon.Position = Vector2.new(screenPos.X, screenPos.Y + yOffset)
                    elements.Weapon.Visible = true
                    yOffset = yOffset + 15
                else
                    elements.Weapon.Visible = false
                end
                if ESPSettings.ShowState then
                    elements.State.Text = humanoid:GetState().Name
                    elements.State.Color = currentColor
                    elements.State.Position = Vector2.new(screenPos.X, screenPos.Y + yOffset)
                    elements.State.Visible = true
                    yOffset = yOffset + 15
                else
                    elements.State.Visible = false
                end

                if ESPSettings.ShowBoxes and not ESPSettings.ShowGlow then
                    local size = Vector3.new(4, 6, 0)
                    local cf = CFrame.new(rootPart.Position) * CFrame.new(0, -size.Y/2, 0)
                    local points = {
                        cf * CFrame.new(size.X/2, size.Y/2, 0),
                        cf * CFrame.new(-size.X/2, size.Y/2, 0),
                        cf * CFrame.new(-size.X/2, -size.Y/2, 0),
                        cf * CFrame.new(size.X/2, -size.Y/2, 0)
                    }
                    local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge
                    local boxOnScreen = true
                    for _, point in ipairs(points) do
                        local screenPoint, pointOnScreen = Camera:WorldToViewportPoint(point.Position)
                        if not pointOnScreen then
                            boxOnScreen = false
                            break
                        end
                        minX = math.min(minX, screenPoint.X)
                        minY = math.min(minY, screenPoint.Y)
                        maxX = math.max(maxX, screenPoint.X)
                        maxY = math.max(maxY, screenPoint.Y)
                    end

                    if boxOnScreen then
                        elements.Box.PointA = Vector2.new(minX, minY)
                        elements.Box.PointB = Vector2.new(maxX, minY)
                        elements.Box.PointC = Vector2.new(maxX, maxY)
                        elements.Box.PointD = Vector2.new(minX, maxY)
                        elements.Box.Color = currentColor
                        elements.Box.Transparency = 1 - alpha
                        elements.Box.Visible = true
                    else
                        hideBox(elements)
                    end
                else
                    hideBox(elements)
                end

                if ESPSettings.ShowHealthBars then
                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                    local barX = screenPos.X - 30
                    local barYTop = screenPos.Y - 20
                    local barYBottom = screenPos.Y + 20
                    elements.HealthBar.From = Vector2.new(barX, barYBottom)
                    elements.HealthBar.To = Vector2.new(barX, barYBottom - (barYBottom - barYTop) * healthPercent)
                    elements.HealthBar.Color = Color3.fromHSV(2/3 * (1 - healthPercent), 1, 1)
                    elements.HealthBar.Transparency = 1 - alpha
                    elements.HealthBar.Visible = true
                else
                    elements.HealthBar.Visible = false
                end

                if ESPSettings.ShowTracers then
                    elements.Tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2 + 20)
                    elements.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                    elements.Tracer.Color = ESPSettings.TracerColor
                    elements.Tracer.Thickness = 1
                    elements.Tracer.Transparency = 1 - alpha
                    elements.Tracer.Visible = true
                else
                    elements.Tracer.Visible = false
                end

                if ESPSettings.ShowSkeleton and onScreen then
                    local skel = elements.Skeleton
                    local bodyPoints = {}
                    if head then table.insert(bodyPoints, {name = "head", pos = head.Position}) end
                    if upperTorso then table.insert(bodyPoints, {name = "upper", pos = upperTorso.Position}) end
                    if lowerTorso then table.insert(bodyPoints, {name = "lower", pos = lowerTorso.Position}) end
                    if torso then table.insert(bodyPoints, {name = "torso", pos = torso.Position}) end
                    if leftArm then table.insert(bodyPoints, {name = "leftarm", pos = leftArm.Position}) end
                    if rightArm then table.insert(bodyPoints, {name = "rightarm", pos = rightArm.Position}) end
                    if leftLeg then table.insert(bodyPoints, {name = "leftleg", pos = leftLeg.Position}) end
                    if rightLeg then table.insert(bodyPoints, {name = "rightleg", pos = rightLeg.Position}) end

                    for i = 1, #bodyPoints - 1 do
                        local p1Screen, p1On = Camera:WorldToViewportPoint(bodyPoints[i].pos)
                        local p2Screen, p2On = Camera:WorldToViewportPoint(bodyPoints[i+1].pos)
                        if p1On and p2On then
                            local line = skel[bodyPoints[i].name .. "to" .. bodyPoints[i+1].name] or skel.HeadToTorso
                            if line then
                                line.From = Vector2.new(p1Screen.X, p1Screen.Y)
                                line.To = Vector2.new(p2Screen.X, p2Screen.Y)
                                line.Color = currentColor
                                line.Transparency = 1 - alpha
                                line.Visible = true
                            end
                        end
                    end
                else
                    local skel = elements.Skeleton
                    for _, line in pairs(skel) do
                        line.Visible = false
                    end
                end
            else
                hideTextElements(elements)
                hideBox(elements)
                local skel = elements.Skeleton
                for _, line in pairs(skel) do
                    line.Visible = false
                end
                if elements.Highlight then
                    elements.Highlight.Enabled = false
                end

                if ESPSettings.ShowArrows then
                    local dir = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)).Unit
                    local arrowPos = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2) + dir * math.min(100, viewportSize.X / 4)
                    local perp = Vector2.new(-dir.Y, dir.X)
                    local size = 20
                    elements.Arrow.PointA = arrowPos + dir * size
                    elements.Arrow.PointB = arrowPos + perp * size / 2 - dir * size / 2
                    elements.Arrow.PointC = arrowPos - perp * size / 2 - dir * size / 2
                    elements.Arrow.Color = ESPSettings.ArrowColor
                    elements.Arrow.Visible = true
                else
                    elements.Arrow.Visible = false
                end
            end
        end

        if updateCache then
            cacheTimer = 0
        end
    end)
end)

local Hitbox = Window:CreateTab("Hitbox")
_G.HeadSize = 5
_G.Disabled = true
_G.HitboxTransparency = 0.7
_G.HitboxColor = BrickColor.new("Really blue")
local hitboxTimer = 0
Hitbox:CreateToggle({
    Name = "Hitbox ON/OFF",
    CurrentValue = false,
    Callback = function(Value)
        _G.Disabled = not Value
        Rayfield:Notify({
            Title = "Hitbox",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
        pcall(function()
            for _, pl in pairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer then
                    local char = pl.Character
                    if char then
                        local head = char:FindFirstChild("Head")
                        local humanoid = char:FindFirstChild("Humanoid")
                        if head and humanoid and humanoid.Health > 0 then
                            if not _G.Disabled then
                                pcall(function()
                                    head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                                    head.Transparency = _G.HitboxTransparency
                                    head.BrickColor = _G.HitboxColor
                                    head.Material = Enum.Material.ForceField
                                    head.CanCollide = false
                                end)
                            else
                                pcall(function()
                                    head.Size = Vector3.new(1, 1, 1)
                                    head.Transparency = 0
                                    head.Material = Enum.Material.SmoothPlastic
                                    head.CanCollide = false
                                end)
                            end
                        end
                    end
                end
            end
        end)
    end
})
Hitbox:CreateSlider({
    Name = "Hitbox Size",
    Range = {2, 60},
    Increment = 1,
    Suffix = "",
    CurrentValue = _G.HeadSize,
    Callback = function(Value)
        _G.HeadSize = Value
        pcall(function()
            for _, pl in pairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("Head") and not _G.Disabled then
                    local humanoid = pl.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local head = pl.Character.Head
                        pcall(function()
                            head.Size = Vector3.new(Value, Value, Value)
                        end)
                    end
                end
            end
        end)
    end
})
Hitbox:CreateSlider({
    Name = "Hitbox Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = _G.HitboxTransparency,
    Callback = function(Value)
        _G.HitboxTransparency = Value
        pcall(function()
            for _, pl in pairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("Head") and not _G.Disabled then
                    local humanoid = pl.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local head = pl.Character.Head
                        pcall(function()
                            head.Transparency = Value
                        end)
                    end
                end
            end
        end)
    end
})
Hitbox:CreateColorPicker({
    Name = "Hitbox Color",
    Color = Color3.fromRGB(0,0,255),
    Callback = function(Value)
        _G.HitboxColor = BrickColor.new(Value)
        pcall(function()
            for _, pl in pairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("Head") and not _G.Disabled then
                    local humanoid = pl.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local head = pl.Character.Head
                        pcall(function()
                            head.BrickColor = _G.HitboxColor
                        end)
                    end
                end
            end
        end)
    end
})

local function setupHitboxForPlayer(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(0.1)
        local head = character:WaitForChild("Head", 5)
        local humanoid = character:WaitForChild("Humanoid", 5)
        if head and humanoid and humanoid.Health > 0 and not _G.Disabled then
            pcall(function()
                head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                head.Transparency = _G.HitboxTransparency
                head.BrickColor = _G.HitboxColor
                head.Material = Enum.Material.ForceField
                head.CanCollide = false
            end)
        end
    end)
    if player.Character and not _G.Disabled then
        task.spawn(function()
            task.wait(0.1)
            local head = player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if head and humanoid and humanoid.Health > 0 then
                pcall(function()
                    head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                    head.Transparency = _G.HitboxTransparency
                    head.BrickColor = _G.HitboxColor
                    head.Material = Enum.Material.ForceField
                    head.CanCollide = false
                end)
            end
        end)
    end
end

for _, pl in pairs(Players:GetPlayers()) do
    if pl ~= LocalPlayer then
        setupHitboxForPlayer(pl)
    end
end
Players.PlayerAdded:Connect(function(pl)
    if pl ~= LocalPlayer then
        setupHitboxForPlayer(pl)
    end
end)

RunService.Heartbeat:Connect(function(delta)
    if protectionBetaEnabled and betaBackoff > 2 then return end
    hitboxTimer = hitboxTimer + delta
    if not _G.Disabled then
        for _,v in pairs(Players:GetPlayers()) do
            if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Head") then
                local humanoid = v.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    pcall(function()
                        local head = v.Character.Head
                        local currentSize = _G.HeadSize + (hitboxProtectionEnabled and math.random(-0.08, 0.08) or 0)
                        head.Size = Vector3.new(currentSize, currentSize, currentSize)
                        head.Transparency = _G.HitboxTransparency + (hitboxProtectionEnabled and math.random(-0.008, 0.008) or 0)
                        head.BrickColor = _G.HitboxColor
                        head.Material = Enum.Material.ForceField
                        head.CanCollide = false
                    end)
                end
            end
        end
        if hitboxProtectionEnabled and hitboxTimer > hitboxResetInterval then
            hitboxTimer = 0
            for _,v in pairs(Players:GetPlayers()) do
                if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Head") then
                    local humanoid = v.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local head = v.Character.Head
                        head.Size = Vector3.new(1, 1, 1)
                        head.Transparency = 0
                        head.CanCollide = false
                        task.spawn(function()
                            task.wait(0.0005)
                            head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                            head.Transparency = _G.HitboxTransparency
                            head.CanCollide = false
                        end)
                    end
                end
            end
        end
    end
end)

local PlayerTab = Window:CreateTab("Player")
PlayerTab:CreateToggle({
    Name = "Speed Boost ON/OFF",
    CurrentValue = boostEnabled.speed,
    Callback = function(Value)
        boostEnabled.speed = Value
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            if not Value then
                humanoid.WalkSpeed = defaultValues.speed
            else
                humanoid.WalkSpeed = boostValues.speed * HedlisProtocol.velocityShield
            end
        end
        Rayfield:Notify({
            Title = "Speed Boost",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
PlayerTab:CreateSlider({
    Name = "Speed Boost Value",
    Range = {16, 300},
    Increment = 1,
    Suffix = "",
    CurrentValue = boostValues.speed,
    Callback = function(Value)
        boostValues.speed = Value
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid and boostEnabled.speed then
            humanoid.WalkSpeed = Value * HedlisProtocol.velocityShield
        end
    end
})

PlayerTab:CreateToggle({
    Name = "Jump Boost ON/OFF",
    CurrentValue = boostEnabled.jump,
    Callback = function(Value)
        boostEnabled.jump = Value
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
            if not Value then
                local prop = isR15 and "JumpHeight" or "JumpPower"
                local defVal = isR15 and defaultValues.jump.height or defaultValues.jump.power
                humanoid[prop] = defVal
            else
                local prop = isR15 and "JumpHeight" or "JumpPower"
                humanoid[prop] = boostValues.jump * HedlisProtocol.jumpBackoff
            end
        end
        Rayfield:Notify({
            Title = "Jump Boost",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
PlayerTab:CreateSlider({
    Name = "Jump Boost Value",
    Range = {7.2, 150},
    Increment = 0.5,
    Suffix = "",
    CurrentValue = boostValues.jump,
    Callback = function(Value)
        boostValues.jump = Value
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid and boostEnabled.jump then
            local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
            local prop = isR15 and "JumpHeight" or "JumpPower"
            humanoid[prop] = Value * HedlisProtocol.jumpBackoff
        end
    end
})
PlayerTab:CreateToggle({
    Name = "Infinite Jump ON/OFF",
    CurrentValue = infJumpEnabled,
    Callback = function(Value)
        infJumpEnabled = Value
        Rayfield:Notify({
            Title = "Infinite Jump",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
PlayerTab:CreateToggle({
    Name = "Auto-Bhop ON/OFF",
    CurrentValue = autoBhopEnabled,
    Callback = function(Value)
        autoBhopEnabled = Value
        Rayfield:Notify({
            Title = "Auto-Bhop",
            Content = Value and "Enabled" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
PlayerTab:CreateToggle({
    Name = "Air-Walk Mode ON/OFF",
    CurrentValue = airWalkEnabled,
    Callback = function(Value)
        airWalkEnabled = Value
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.PlatformStand = Value
        end
        if not Value and bodyVelocity then
            bodyVelocity:Destroy()
            bodyVelocity = nil
        end
        Rayfield:Notify({
            Title = "Air-Walk",
            Content = Value and "Enabled (WASD QE to move)" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})
PlayerTab:CreateSlider({
    Name = "Air-Walk Speed",
    Range = {16, 300},
    Increment = 1,
    Suffix = "",
    CurrentValue = flySpeed,
    Callback = function(Value)
        flySpeed = Value
    end
})

PlayerTab:CreateSection("Movement Hacks")
noclipConnection = nil
PlayerTab:CreateToggle({
    Name = "Noclip ON/OFF",
    CurrentValue = noclipEnabled,
    Callback = function(Value)
        noclipEnabled = Value
        local character = LocalPlayer.Character
        if not character then return end

        if Value then
            noclipConnection = RunService.Stepped:Connect(function(time, deltaTime)
                noclipClipTimer = noclipClipTimer + deltaTime
                if not noclipEnabled or not character then return end
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part ~= character:FindFirstChild("HumanoidRootPart") then
                        part.CanCollide = false
                    end
                end
                local root = character:FindFirstChild("HumanoidRootPart")
                if root then
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {character}
                    local directions = {
                        root.CFrame.LookVector * 5,
                        -root.CFrame.LookVector * 5,
                        root.CFrame.RightVector * 5,
                        -root.CFrame.RightVector * 5,
                        Vector3.new(0, 5, 0),
                        Vector3.new(0, -5, 0)
                    }
                    for _, dir in pairs(directions) do
                        local raycast = Workspace:Raycast(root.Position, dir, rayParams)
                        if raycast and raycast.Distance < 1.5 then
                            local adjustDist = 1.5 - raycast.Distance
                            root.CFrame = root.CFrame + (dir.Unit * adjustDist)
                        end
                    end
                end
                for _, accessory in pairs(character:GetChildren()) do
                    if accessory:IsA("Accessory") then
                        local handle = accessory:FindFirstChild("Handle")
                        if handle then
                            handle.CanCollide = false
                        end
                    end
                end

                if noclipClipTimer > 0.01 then
                    local microAdjust = Vector3.new(math.random(-0.035, 0.035), math.random(-0.02, 0.02), math.random(-0.035, 0.035))
                    root.CFrame = root.CFrame + microAdjust * HedlisProtocol.velocityShield
                    noclipClipTimer = 0
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
            for _, accessory in pairs(character:GetChildren()) do
                if accessory:IsA("Accessory") then
                    local handle = accessory:FindFirstChild("Handle")
                    if handle then
                        handle.CanCollide = true
                    end
                end
            end
        end
        Rayfield:Notify({
            Title = "Noclip",
            Content = Value and "Enabled (Phase Mode Smooth)" or "Disabled",
            Duration = 3,
            Image = Value and 4483362458 or 4483362741
        })
    end
})

local function TeleportToNearestPlayer()
    if teleportCooldown > 0 then return end
    teleportCooldown = 5
    local closestPlayer = nil
    local closestDist = math.huge
    local playerPos = LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart.Position
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if TeamCheck.Settings.AimbotTeamCheck and not TeamCheck:isEnemy(player) then
                continue
            end
            local dist = (playerPos - player.Character.HumanoidRootPart.Position).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPlayer = player
            end
        end
    end
    if closestPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetCFrame = closestPlayer.Character.HumanoidRootPart.CFrame
        LocalPlayer.Character.HumanoidRootPart.CFrame = targetCFrame

        task.wait(0.002)
        local root = LocalPlayer.Character.HumanoidRootPart
        local noiseOffset = Vector3.new(math.random(-0.35,0.35), math.random(-0.2,0.2), math.random(-0.35,0.35)) * HedlisProtocol.velocityShield
        root.CFrame = root.CFrame + noiseOffset

        task.spawn(function()
            task.wait(0.01)
            root.Velocity = root.Velocity + Vector3.new(math.random(-0.25, 0.25), 0, math.random(-0.25, 0.25)) * HedlisProtocol.velocityShield
        end)

        Rayfield:Notify({
            Title = "Teleport",
            Content = "Teleported to " .. closestPlayer.Name,
            Duration = 3,
            Image = 4483362458
        })
    else
        Rayfield:Notify({
            Title = "Teleport",
            Content = "No valid player found",
            Duration = 3,
            Image = 4483362741
        })
    end
    task.spawn(function()
        task.wait(5)
        teleportCooldown = 0
    end)
end

PlayerTab:CreateButton({
    Name = "Teleport to Nearest Player",
    Callback = function()
        TeleportToNearestPlayer()
    end
})

local teleportKey = Enum.KeyCode.T
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == teleportKey then
        TeleportToNearestPlayer()
    end
end)

PlayerTab:CreateKeybind({
    Name = "Teleport Keybind (Fallback)",
    CurrentKeybind = "T",
    HoldToInteract = false,
    Callback = function(Keybind)
        
    end,
})
PlayerTab:CreateButton({
    Name = "Create Mobile Teleport Button",
    Callback = function()
        pcall(function() game.CoreGui:FindFirstChild("MobileTeleport"):Destroy() end)

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "MobileTeleport"
        screenGui.Parent = game.CoreGui

        local frame = Instance.new("Frame")
        frame.Name = "DragFrame"
        frame.Parent = screenGui
        frame.BackgroundColor3 = Color3.new(0, 0, 0)
        frame.Size = UDim2.new(0, 100, 0, 100)
        frame.Position = UDim2.new(0.5, -50, 0.5, -50)
        frame.Active = true
        frame.Draggable = true

        local textLabel = Instance.new("TextLabel")
        textLabel.Name = "Label"
        textLabel.Parent = frame
        textLabel.BackgroundTransparency = 1
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Text = "TP"
        textLabel.TextColor3 = Color3.new(1, 1, 1)
        textLabel.TextScaled = true

        frame.Activated:Connect(function()
            TeleportToNearestPlayer()
        end)

        textLabel.MouseButton1Click:Connect(function()
            TeleportToNearestPlayer()
        end)

        Rayfield:Notify({
            Title = "Mobile Button",
            Content = "Draggable black button created for mobile teleport. Tap to teleport! (Fixed for multiple uses)",
            Duration = 5,
            Image = 4483362458
        })
    end
})

local function isAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    return humanoid and humanoid.Health and humanoid.Health > 0
end

local function AnalyzeShot(targetCharacter, targetPartInstance)
    if not targetCharacter then return end
    local head = targetPartInstance or targetCharacter:FindFirstChild("Head")
    if not head then return end

    local fireDirection = Camera.CFrame.LookVector
    local actualRay = Workspace:Raycast(Camera.CFrame.Position, fireDirection * 5000)

    local idealDirection = (head.Position - Camera.CFrame.Position).Unit

    local dotProduct = fireDirection:Dot(idealDirection)
    local crossProduct = fireDirection:Cross(idealDirection)

    if dotProduct < 0.999 then
        local vel = (targetCharacter:FindFirstChild("HumanoidRootPart") and targetCharacter.HumanoidRootPart.Velocity) or Vector3.new()
        local targetVelocityDirection = (vel.Magnitude > 0.01) and vel.Unit or Vector3.new(0,0,0)

        local rightDot = targetVelocityDirection:Dot(Camera.CFrame.RightVector)
        local errorSign = (crossProduct.Y * rightDot) > 0 and 1 or -1

        local errorMagnitude = 1 - dotProduct
        local calculatedError = errorMagnitude * errorSign * 25

        table.insert(HephaestusProtocol.shotHistory, calculatedError)
        if #HephaestusProtocol.shotHistory > HephaestusProtocol.shotsToAnalyze then
            table.remove(HephaestusProtocol.shotHistory, 1)
        end
    end
end

local function computePrediction(part, originPos)
    if not part or not originPos then
        return part and part.Position or originPos or Vector3.new(0,0,0)
    end
    local vel = part.Velocity or Vector3.new()
    local distance = (originPos - part.Position).Magnitude
    local fpsAdjustedSpeed = 1800 * (currentFps / 60)
    local timeFactor = math.clamp(distance / fpsAdjustedSpeed, 0.05, currentMultiplier.timeFactor or 0.18)
    local dampedVel = vel * ((currentMultiplier.velocityDamp or 0.55) + math.random() * 0.06)
    local predicted = part.Position + (dampedVel * timeFactor * (adaptiveThreshold or 1))
    if overshootFactor and overshootFactor > 0 then
        predicted = predicted + (dampedVel.Unit * overshootFactor * 0.03)
    end
    if protectionAlphaEnabled then
        predicted = predicted + (currentNoise or Vector3.new())
    end
    predicted = predicted + Vector3.new(ToshitaProtocol.quantumAim, 0, ToshitaProtocol.quantumAim)
    return predicted
end

_G.computePrediction = computePrediction

local function getClosestTarget()
    local cameraPos = Camera.CFrame.Position
    local shortestDistance = math.huge
    local chosen = nil
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local candidates = {}
    local skippedCount = 0
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and isAlive(player.Character) then
            if TeamCheck.Settings.AimbotTeamCheck and not TeamCheck:isEnemy(player) then
                skippedCount = skippedCount + 1
                continue
            end
            local partName = targetPart
            if targetPart == "Random" then
                local isR15 = player.Character:FindFirstChild("UpperTorso") ~= nil
                local r15Parts = {"Head", "UpperTorso", "LowerTorso", "HumanoidRootPart"}
                local r6Parts = {"Head", "Torso", "HumanoidRootPart"}
                local availableParts = isR15 and r15Parts or r6Parts
                partName = availableParts[math.random(1, #availableParts)]
            end
            local part = player.Character:FindFirstChild(partName)
            if not part and (targetPart == "UpperTorso" or targetPart == "LowerTorso") then
                part = player.Character:FindFirstChild("Torso")
            end
            if part then
                local dist = (cameraPos - part.Position).Magnitude
                if dist <= (aimbotMaxDistance or 1000) then
                    local effectiveFov = (fovRadius or 100) + (currentFovVariance or 0)
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
                        if screenDist <= effectiveFov then
                            local ok = true
                            if aimbotWallCheck then
                                ok = hasLineOfSight(cameraPos, player.Character, {LocalPlayer.Character, player.Character})
                                if not ok then
                                    skippedCount = skippedCount + 1
                                end
                            end
                            if ok then
                                table.insert(candidates, {player = player, part = part, dist = dist, screenDist = screenDist})
                            else
                                skippedCount = skippedCount + 1
                            end
                        end
                    end
                end
            end
        end
    end
    for _, part in ipairs(_G.ValidTargetParts or {}) do
        if part and part.Parent and part:IsDescendantOf(Workspace) and not part:IsDescendantOf(LocalPlayer.Character) then
            local dist = (cameraPos - part.Position).Magnitude
            if dist <= aimbotMaxDistance then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
                    local effectiveFov = (fovRadius or 100) + (currentFovVariance or 0)
                    if screenDist <= effectiveFov then
                        local ok = true
                        if aimbotWallCheck then
                            ok = hasLineOfSight(cameraPos, nil, {LocalPlayer.Character})
                        end
                        if ok then
                            table.insert(candidates, {part = part, dist = dist, screenDist = screenDist, isDynamic = true})
                        end
                    end
                end
            end
        end
    end
    if #candidates > 0 then
        table.sort(candidates, function(a, b) return a.screenDist < b.screenDist end)
        chosen = candidates[1]
        shortestDistance = candidates[1].dist
    elseif skippedCount > 0 then

    end
    return chosen
end

_G.getClosestTarget = getClosestTarget

local function getClosestTargetWithSticky()
    local chosen = getClosestTarget()
    local currentTime = tick()
    if chosen then
        lastTargetData = chosen
        stickyTime = currentTime
    elseif stickyEnabled and lastTargetData and lastTargetData.part and (currentTime - stickyTime) < stickyDuration then
        local dist = (Camera.CFrame.Position - lastTargetData.part.Position).Magnitude
        if dist <= aimbotMaxDistance and isAlive(lastTargetData.player and lastTargetData.player.Character) then
            chosen = lastTargetData
        end
    end
    return chosen
end

if DrawingAvailable then
    FOVCircleDrawing = Drawing.new("Circle")
    FOVCircleDrawing.Transparency = 1
    FOVCircleDrawing.Thickness = 2
    FOVCircleDrawing.Filled = false
    FOVCircleDrawing.Radius = fovRadius
    FOVCircleDrawing.Color = Color3.new(0.5, 0, 0.5)
end

local hephaestusTimer = 0
local aimbotCoreConnection = RunService.Heartbeat:Connect(function(delta)
    Aegis:SafeRun("Aimbot", function()
        if not delta then return end
        noiseTimer = noiseTimer + delta
        speedTimer = speedTimer + delta
        pauseTimer = pauseTimer + delta
        fovVarianceTimer = fovVarianceTimer + delta
        curveIndex = (curveIndex % #easingCurve) + 1
        reactionTimer = reactionTimer + delta
        overshootTimer = overshootTimer + delta
        backoffTimer = backoffTimer + delta
        backoffResetTimer = backoffResetTimer + delta
        lagTimer = lagTimer + delta
        polyTimer = polyTimer + delta
        fractalTimer = fractalTimer + delta
        thresholdTimer = thresholdTimer + delta
        quantumTimer = quantumTimer + delta
        integrityCheckTimer = integrityCheckTimer + delta
        uiObfuscateTimer = uiObfuscateTimer + delta
        aimIntelligenceTimer = aimIntelligenceTimer + delta

        hephaestusTimer = hephaestusTimer + delta
        if hephaestusTimer > 0.25 then
            hephaestusTimer = 0
            if #HephaestusProtocol.shotHistory >= HephaestusProtocol.shotsToAnalyze then
                local sum = 0
                for _, err in ipairs(HephaestusProtocol.shotHistory) do
                    sum = sum + err
                end
                HephaestusProtocol.predictionError = sum / #HephaestusProtocol.shotHistory

                if math.abs(HephaestusProtocol.predictionError) > HephaestusProtocol.errorThreshold then
                    local oldFactor = currentMultiplier.timeFactor
                    if HephaestusProtocol.predictionError > 0 then
                        currentMultiplier.timeFactor = currentMultiplier.timeFactor + HephaestusProtocol.learningRate * 1.8
                    else
                        currentMultiplier.timeFactor = currentMultiplier.timeFactor - HephaestusProtocol.learningRate * 1.8
                    end
                    currentMultiplier.timeFactor = math.clamp(currentMultiplier.timeFactor, HephaestusProtocol.minTimeFactor, HephaestusProtocol.maxTimeFactor)
                    if oldFactor ~= currentMultiplier.timeFactor then
                        HephaestusProtocol.shotHistory = {}
                    end
                end
            end
        end

        if intelligentAimMode and aimIntelligenceTimer > 0.04 then
            local recentAccuracy = (#HephaestusProtocol.shotHistory > 0) and (1 - math.abs(HephaestusProtocol.predictionError)) or 1
            if recentAccuracy < safetyThreshold then
                aimSpeedMultiplier = aimSpeedMultiplier * 0.96
                backoffLevel = math.min(backoffLevel + 0.04, 1.4)
            else
                aimSpeedMultiplier = aimSpeedMultiplier * 1.04
                backoffLevel = math.max(backoffLevel - 0.012, 1)
            end
            aimIntelligenceTimer = 0
        end

        if protectionAlphaEnabled then
            if noiseTimer > 0.08 then
                polyNoiseSeed = polyNoiseSeed + 1
                local safeMaxNoise = maxNoise or 0.05
                local baseNoise = math.random(-safeMaxNoise, safeMaxNoise) * 1.0
                local sinLayer = math.sin(tick() * 10.5) * (safeMaxNoise * 0.035)
                local polyLayer = (math.noise(polyNoiseSeed * 0.1, 0, 0) * 2 - 1) * (safeMaxNoise * 0.07)
                local fractalLayer = 0
                for i = 1, hyperNoiseLayers do
                    fractalLayer = fractalLayer + (math.noise(fractalTimer * i * 3.0, polyNoiseSeed * 0.04, 0) * 2 - 1) * (safeMaxNoise * 0.035 / i)
                end
                currentNoise = Vector3.new(
                    baseNoise + sinLayer + polyLayer + fractalLayer + targetJitter,
                    math.random(-safeMaxNoise / 2, safeMaxNoise / 2) + sinLayer * 0.25,
                    baseNoise + sinLayer + polyLayer + fractalLayer + targetJitter
                )
                noiseTimer = 0
            end

            if speedTimer > 0.05 then
                aimSpeedMultiplier = 0.998 + math.random() * 0.01
                speedTimer = 0
            end

            if fovVarianceTimer > 0.2 then
                currentFovVariance = math.random(-1, 1)
                fovVarianceTimer = 0
            end

            if pauseChance > math.random() then return end
            if pauseTimer > 0.0008 then pauseTimer = 0 end

            if reactionChance > math.random() then
                local reactionDelay = 0.08
                if reactionTimer > reactionDelay then
                    reactionTimer = 0
                else
                    return
                end
            end
            reactionTimer = 0

            if overshootTimer > 0.1 then
                overshootFactor = math.random(0, 1) * 0.04
                overshootTimer = 0
            end
            if overshootFactor > 0 then overshootFactor = overshootFactor * 0.996 end

            if backoffTimer > 0.003 * backoffLevel then
                if math.random() > 0.988 then
                    backoffLevel = math.clamp(backoffLevel + 0.035, 1, 1.4)
                end
                backoffTimer = 0
            end

            if backoffResetTimer > 0.06 then
                backoffLevel = math.max(1, backoffLevel - 0.06)
                backoffResetTimer = 0
            end

            fractalTimer = fractalTimer + delta * 0.5
            if math.random() < 0.0035 then
                local rand = math.random()
                local dt1 = decisionTree[1] or 0.5
                local dt2 = decisionTree[2] or 0.4
                if rand < dt1 then decisionIndex = 1
                elseif rand < dt1 + dt2 then decisionIndex = 2
                else decisionIndex = 3 end
            end

            if thresholdTimer > 0.015 then
                local playerCount = #Players:GetPlayers()
                adaptiveThreshold = math.clamp(1.0 + (playerCount > 12 and -0.01 or 0.006) * decisionIndex * thresholdSensitivity * 2.5, 0.97, 1.03)
                thresholdTimer = 0
            end

            if quantumTimer > 0.006 then
                quantumRand = math.sin(quantumRand + tick() * math.random(0.06, 0.45)) * 0.2
                quantumTimer = 0
            end
            aimSpeedMultiplier = aimSpeedMultiplier * (1 + quantumRand * 0.006)
        end

        if protectionBetaEnabled then
            if lagTimer > 0.006 then
                networkLagMimic = math.random(0, 1) / 1000
                lagTimer = 0
            end
            delta = delta + networkLagMimic

            if #remoteSpoofQueue > 0 then
                table.remove(remoteSpoofQueue, 1)
            end
            table.insert(remoteSpoofQueue, math.random())

            if betaBackoff > 1 then
                betaBackoff = betaBackoff * 1.001
            end
        end

        if protectionGammaEnabled then
            if integrityCheckTimer > 0.06 then
                integrityCheckTimer = 0
                if uiObfuscateTimer > 0.03 then
                    uiObfuscateTimer = 0
                end
                if not _G.getClosestTarget or not _G.computePrediction then
                    print("[Enhanced Integrity] Core functions secured - No action needed")
                end
            end
        end

        if antiCheatDetection then
            task.wait(math.random(0.05, 0.5))
            return
        end

        if not aimbotEnabled or backoffLevel > 1.5 then
            return
        end

        local target = getClosestTargetWithSticky()
        if target then
            local part = target.part or (target.player and target.player.Character:FindFirstChild(targetPart))
            local predictedPos = computePrediction(part, Camera.CFrame.Position)
            local ok = true
            if aimbotWallCheck then
                local ignoreList = {LocalPlayer.Character}
                if target.player then
                    table.insert(ignoreList, target.player.Character)
                end
                ok = hasLineOfSight(Camera.CFrame.Position, target.player and target.player.Character or nil, ignoreList)
                if not ok then return end
            end
            if ok then
                local decisionMultiplier = 1
                if protectionAlphaEnabled then
                    if decisionIndex == 1 then decisionMultiplier = 1.008
                    elseif decisionIndex == 3 then decisionMultiplier = 0.992 end
                end
                local baseAlpha = math.clamp(aimbotSpeed * (delta * 60) / backoffLevel * adaptiveThreshold * decisionMultiplier, 0, 1.3)
                local curveAlpha = baseAlpha * easingCurve[curveIndex]
                local finalAlpha = curveAlpha * aimSpeedMultiplier * ToshitaProtocol.backoffAimbot

                if isPC and hasMouseSupport then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
                    if onScreen then
                        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        local deltaX = (screenPos.X - center.X) * finalAlpha * 0.35
                        local deltaY = (screenPos.Y - center.Y) * finalAlpha * 0.35
                        pcall(function()
                            mousemoverel(deltaX + targetJitter, deltaY + targetJitter)
                        end)
                    end
                else
                    local desired = CFrame.lookAt(Camera.CFrame.Position, predictedPos)
                    task.spawn(function()
                        Camera.CFrame = Camera.CFrame:Lerp(desired, finalAlpha * 1.15)
                    end)
                end

                if showAimLine then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        targetLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        targetLine.To = Vector2.new(screenPos.X, screenPos.Y)
                        targetLine.Visible = true
                    else
                        targetLine.Visible = false
                    end
                else
                    targetLine.Visible = false
                end

                if triggerbotEnabled and isPC and tick() - lastFireTime >= fireDelay and target.player then
                    if math.random() < 0.999 then
                        pcall(function()
                            mouse1press()
                            task.wait(math.random(0.00005, 0.0008))
                            mouse1release()
                        end)
                        pcall(function()
                            AnalyzeShot(target.player.Character, part)
                        end)
                        lastFireTime = tick()
                    end
                end
            end
        else
            lastFireTime = 0
            targetLine.Visible = false
        end
    end, delta)
end)

RunService.RenderStepped:Connect(function()
    if DrawingAvailable and FOVCircleDrawing then
        FOVCircleDrawing.Visible = fovEnabled
        if fovEnabled then
            local centerX = Camera.ViewportSize.X / 2
            local centerY = Camera.ViewportSize.Y / 2
            FOVCircleDrawing.Position = Vector2.new(centerX, centerY)
            FOVCircleDrawing.Radius = fovRadius + currentFovVariance
            local hue = (tick() % 5) / 5
            FOVCircleDrawing.Color = Color3.fromHSV(hue, 1, 1)
            local pulse = (math.sin(tick() * 3.5) + 1) / 2 * 0.25
            FOVCircleDrawing.Radius = fovRadius * (1 + pulse) + currentFovVariance
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.E then
        aimbotEnabled = not aimbotEnabled
    end
end)

local AegisTab = Window:CreateTab("Aegis System")

AegisTab:CreateToggle({
    Name = "Enable Aegis Protection",
    CurrentValue = Aegis.Enabled,
    Callback = function(Value)
        Aegis.Enabled = Value
        Rayfield:Notify({ Title = "Aegis System", Content = Value and "Enabled" or "Disabled", Duration = 3 })
    end
})

local aimbotStatus = AegisTab:CreateLabel("Aimbot: OK")
local espStatus = AegisTab:CreateLabel("ESP: OK")
local playerModsStatus = AegisTab:CreateLabel("Player Mods: OK")

task.spawn(function()
    while task.wait(1) do
        local aimbotInfo = Aegis.FeatureHealth.Aimbot
        aimbotStatus:Set( ("Aimbot: %s (%d errors)"):format(aimbotInfo.Status, aimbotInfo.Errors) )

        local espInfo = Aegis.FeatureHealth.ESP
        espStatus:Set( ("ESP: %s (%d errors)"):format(espInfo.Status, espInfo.Errors) )
        
        local modsInfo = Aegis.FeatureHealth.PlayerMods
        playerModsStatus:Set( ("Player Mods: %s (%d errors)"):format(modsInfo.Status, modsInfo.Errors) )
    end
end)

AegisTab:CreateButton({
    Name = "View Error Log",
    Callback = function()
        local logContent = "Aegis Error Log:\n"
        if #Aegis.ErrorLog == 0 then
            logContent = "No errors have been logged."
        else
            for i, entry in ipairs(Aegis.ErrorLog) do
                logContent = logContent .. string.format("[%d] %s: %s\n", i, entry.Feature, entry.Error)
            end
        end
        Rayfield:Notify({ Title = "Error Log", Content = logContent, Duration = 15 })
        print(logContent)
    end
})

Rayfield:LoadConfiguration()
